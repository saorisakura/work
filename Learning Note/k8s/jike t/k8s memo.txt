Docker
	OS requirements
	To install Docker CE, you need a maintained version of CentOS 7. Archived versions aren’t supported or tested.

	The centos-extras repository must be enabled. This repository is enabled by default, but if you have disabled it, you need to re-enable it.

	The overlay2 storage driver is recommended.

	Uninstall old versions
	Older versions of Docker were called docker or docker-engine. If these are installed, uninstall them, along with associated dependencies.

	$ sudo yum remove docker \
					  docker-client \
					  docker-client-latest \
					  docker-common \
					  docker-latest \
					  docker-latest-logrotate \
					  docker-logrotate \
					  docker-engine
	It’s OK if yum reports that none of these packages are installed.

	The contents of /var/lib/docker/, including images, containers, volumes, and networks, are preserved. The Docker CE package is now called docker-ce.
	
	Install using the repository
	Before you install Docker CE for the first time on a new host machine, you need to set up the Docker repository. Afterward, you can install and update Docker from the repository.

	SET UP THE REPOSITORY
	Install required packages. yum-utils provides the yum-config-manager utility, and device-mapper-persistent-data and lvm2 are required by the devicemapper storage driver.

	$ sudo yum install -y yum-utils \
	  device-mapper-persistent-data \
	  lvm2
	Use the following command to set up the stable repository.

	$ sudo yum-config-manager \
		--add-repo \
		https://download.docker.com/linux/centos/docker-ce.repo
	
	INSTALL DOCKER CE
	yum install docker-ce docker-ce-cli containerd.io
	yum install docker-ce-<VERSION_STRING> docker-ce-cli-<VERSION_STRING> containerd.io
	systemctl start docker
	docker run hello-world
	
	UPGRADE DOCKER CE
	To upgrade Docker CE, follow the installation instructions, choosing the new version you want to install.
	
	Install from a package
	https://download.docker.com/linux/centos/7/x86_64/stable/Packages/ 
	
	yum install /path/to/package.rpm

Namespace
	$ docker run -it busybox /bin/sh
	/ #
	这个命令是 Docker 项目最重要的一个操作，即大名鼎鼎的 docker run。

	而 -it 参数告诉了 Docker 项目在启动容器后，需要给我们分配一个文本输入 / 输出环境，也就是 TTY，跟容器的标准输入相关联，这样我们就可以和这个 Docker 容器进行交互了。而 /bin/sh 就是我们要在 Docker 容器里运行的程序。

	所以，上面这条指令翻译成人类的语言就是：请帮我启动一个容器，在容器里执行 /bin/sh，并且给我分配一个命令行终端跟这个容器交互。

	这样，我的 Ubuntu 16.04 机器就变成了一个宿主机，而一个运行着 /bin/sh 的容器，就跑在了这个宿主机里面。

	上面的例子和原理，如果你已经玩过 Docker，一定不会感到陌生。此时，如果我们在容器里执行一下 ps 指令，就会发现一些更有趣的事情：

	/ # ps
	PID  USER   TIME COMMAND
	  1 root   0:00 /bin/sh
	  10 root   0:00 ps
	可以看到，我们在 Docker 里最开始执行的 /bin/sh，就是这个容器内部的第 1 号进程（PID=1），而这个容器里一共只有两个进程在运行。这就意味着，前面执行的 /bin/sh，以及我们刚刚执行的 ps，已经被 Docker 隔离在了一个跟宿主机完全不同的世界当中。

	这究竟是怎么做到呢？

	本来，每当我们在宿主机上运行了一个 /bin/sh 程序，操作系统都会给它分配一个进程编号，比如 PID=100。这个编号是进程的唯一标识，就像员工的工牌一样。所以 PID=100，可以粗略地理解为这个 /bin/sh 是我们公司里的第 100 号员工，而第 1 号员工就自然是比尔 · 盖茨这样统领全局的人物。

	而现在，我们要通过 Docker 把这个 /bin/sh 程序运行在一个容器当中。这时候，Docker 就会在这个第 100 号员工入职时给他施一个“障眼法”，让他永远看不到前面的其他 99 个员工，更看不到比尔 · 盖茨。这样，他就会错误地以为自己就是公司里的第 1 号员工。

	这种机制，其实就是对被隔离应用的进程空间做了手脚，使得这些进程只能看到重新计算过的进程编号，比如 PID=1。可实际上，他们在宿主机的操作系统里，还是原来的第 100 号进程。

	这种技术，就是 Linux 里面的 Namespace 机制。而 Namespace 的使用方式也非常有意思：它其实只是 Linux 创建新进程的一个可选参数。我们知道，在 Linux 系统中创建线程的系统调用是 clone()，比如：

	int pid = clone(main_function, stack_size, SIGCHLD, NULL); 
	这个系统调用就会为我们创建一个新的进程，并且返回它的进程号 pid。

	而当我们用 clone() 系统调用创建一个新进程时，就可以在参数中指定 CLONE_NEWPID 参数，比如：

	int pid = clone(main_function, stack_size, CLONE_NEWPID | SIGCHLD, NULL); 
	这时，新创建的这个进程将会“看到”一个全新的进程空间，在这个进程空间里，它的 PID 是 1。之所以说“看到”，是因为这只是一个“障眼法”，在宿主机真实的进程空间里，这个进程的 PID 还是真实的数值，比如 100。

	当然，我们还可以多次执行上面的 clone() 调用，这样就会创建多个 PID Namespace，而每个 Namespace 里的应用进程，都会认为自己是当前容器里的第 1 号进程，它们既看不到宿主机里真正的进程空间，也看不到其他 PID Namespace 里的具体情况。

	而除了我们刚刚用到的 PID Namespace，Linux 操作系统还提供了 Mount、UTS、IPC、Network 和 User 这些 Namespace，用来对各种不同的进程上下文进行“障眼法”操作。

	比如，Mount Namespace，用于让被隔离进程只看到当前 Namespace 里的挂载点信息；Network Namespace，用于让被隔离进程看到当前 Namespace 里的网络设备和配置。

	这，就是 Linux 容器最基本的实现原理了。

Cgroups
	Linux Cgroups 的设计还是比较易用的，简单粗暴地理解呢，它就是一个子系统目录加上一组资源限制文件的组合。而对于 Docker 等 Linux 容器项目来说，它们只需要在每个子系统下面，为每个容器创建一个控制组（即创建一个新目录），然后在启动容器进程之后，把这个进程的 PID 填写到对应控制组的 tasks 文件中就可以了。
	而至于在这些控制组下面的资源文件里填上什么值，就靠用户执行 docker run 时的参数指定了，比如这样一条命令：
	 $ docker run -it --cpu-period=100000 --cpu-quota=20000 ubuntu /bin/bash
	复制代码
	在启动这个容器后，我们可以通过查看 Cgroups 文件系统下，CPU 子系统中，“docker”这个控制组里的资源限制文件的内容来确认：
	 $ cat /sys/fs/cgroup/cpu/docker/5d5c9f67d/cpu.cfs_period_us
	 100000
	 $ cat /sys/fs/cgroup/cpu/docker/5d5c9f67d/cpu.cfs_quota_us
	 20000
	复制代码
	这就意味着这个 Docker 容器，只能使用到 20% 的 CPU 带宽。

Images

K8S












































