散列能够在O(1)的时间内查找到元素
散列表场合链表结合用
动态查找更适合用树形查找，其中偏爱近似平衡的红黑树

线性排序讲究适用场景的排序算法

桶排序: 
1. 原理: 根据数据范围，分成若干个数据段的桶，通过遍历讲数据放到对应的桶中。每个桶里都进行快排或归并。
2. 时间复杂度: 最好o(n), 最坏o(nlogn), 平均o(n)，一般桶分的越细越多复杂度就会最好。
3. 内存消耗: o(n)
4. 稳定性: 取决于每个桶的排序方式，快排就不稳定，归并就稳定。
5. 适用场景: 数据范围不大的。内存吃紧的，如磁盘的读写可以分成多个小文件并对每个小文件排序，然后直接写到大文件里，这个时候内存消耗不再是o(n)了。

计数排序:
1. 原理: 特殊的桶排序，即每个下标代表一个数据范围，其值就是这个数据的个数。
2. 时间复杂度: 都是o(n)
3. 内存消耗: o(n)
4. 稳定性: 稳定，只要整理最后结果时从后开始遍历即可。
5. 适用场景: 数据范围不大的，如年龄排序。

基数排序: 
1. 原理: 对数据的每一位进行桶排序或计数排序，对每位排序后结果就是有序的。
2. 时间复杂度: 最好o(n), 最坏o(nlogn), 平均o(n)
3. 内存消耗: o(n)
4. 稳定性: 稳定。否则就排不成的。
5. 适用场景: 是在桶排序和计数排序基础上进行的，保证每位数据范围不大，并且位数也不是很多。


x&(x-1)表达式的意义

求下面函数的返回值(微软) -- 统计1的个数
-------------------------------------
int func(int x)
{
    int countx = 0;
    while(x)
    {
        countx++;
        x = x&(x-1);
    }
    return countx;
} 

假定x = 9999
10011100001111
答案: 8

思路: 将x转化为2进制，看含有的1的个数。
注: 每执行一次x = x&(x-1)，会将x用二进制表示时最右边的一个1变为0，因为x-1将会将该位(x用二进制表示时最右边的一个1)变为0。




判断一个数(x)是否是2的n次方
-------------------------------------
#include <stdio.h>

int func(int x)
{
    if( (x&(x-1)) == 0 )
        return 1;
    else
        return 0;
}

int main()
{
    int x = 8;
    printf("%d\n", func(x));
}


注: 
(1) 如果一个数是2的n次方，那么这个数用二进制表示时其最高位为1，其余位为0。

(2) == 优先级高于 &



综上可知：表达式x&(x-1)的意义，就是将二进制数据中的最后位的1转换为0.


我们今天讲的都是非常规的二分查找问题，今天的思考题也是一个非常规的二分查找问题。如果有序数组是一个循环有序数组，比如4，5，6，1，2，3.针对这种情况，如何实现一个求“值等于给定值”的二分查找算法

思考题，在leetcode上练习验证通过了，本着实现算法的思想，写了一大段复杂的代码
public static int binaryCycleSearch(int[] nums,int target) {
//二分法将数组分成两部分，要区分出哪部分是有序的
//当nums[mid] > nums[mid-1] 时，前半部分有序
//当nums[mid] < nums[mid + 1]时，后半部分有序
int low = 0;
int high = nums.length - 1;
while (high>=low) {

int mid = low + ((high-low) >> 1);
if(nums[mid] == target) {
return mid;
}
if(high == low) {
return -1;
}
if(mid == 0) {
low = low = mid + 1;
continue;
} else if(mid == high) {
high = mid -1;
continue;
}
if(nums[mid] >=nums[low]) {
//target落在前半部分有序队列中
if(nums[mid] > target && (nums[mid-1] >= target && nums[low] <= target)) {
high = mid - 1;
}
//target未落在有序队列中（后半部分）
else {
low = mid + 1;
}
} else if(nums[mid] < nums[high] ){
//target落在后半部分有序队列中
if(nums[mid] < target && (nums[high] >=target && nums[mid+1] <= target)) {
low = mid + 1;
} else {
high = mid - 1;
}
}

}

return -1;

}


假设我们现在需要对 D，a，F，B，c，A，z 这个字符串进行排序，要求将其中所有小写字母都排在大写字母的前面，但小写字母内部和大写字母内部不要求有序。比如经过排序之后为 a，c，z，D，F，B，A，这个如何来实现呢？如果字符串中存储的不仅有大小写字母，还有数字。要将小写字母的放到前面，大写字母放在最后，数字放在中间，不用排序算法，又该怎么解决呢？

