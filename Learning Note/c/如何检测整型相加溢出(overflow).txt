如何检测整型相加溢出(overflow)

前言:
本文主要讨论如何判断整型相加溢出(overflow)的问题. 我们知道计算机里面整型一般是有限个字节(4 bytes for int)表示, 正是因为只能用有限个字节表示一个整型变量, 由此带来一个可能的问题: 溢出(overflow). 所谓整型溢出(overflow), 是说一个整数的值太大或者太小导致没有用给定的有限个（比如四个字节没法存超过2^31 – 1的有符号正整数）字节存储表示. 这个整型溢出(overflow)问题一般的时候不会注意到也并不危险, 但是在做整型加法或者乘法的时候就有可能出现并且给程序带来未定义的行为. 这里我们主要讨论如何判断整型相加溢出(overflow)的两种方法以及各自优缺点.

整型相加溢出(overflow)的原因:
前言里面也已经提到了, 计算机中的的整数是用有限个字节表示的, 假设用k个字节表示一个整型变量, 那么这个变量可以表示的有符号整数的范围是-2^(8k-1) ~ 2^(8k-1) – 1  ,  那么两个正整数或者两个负整数相加就有可能超过这个整型变量所能表示的范围, 向上超出>2^(8k-1) – 1我们称之为向上溢出, 向下超出<-2^(8k-1), 我们称之为向下溢出. 注意这里两个整数符号相同是整型相加溢出(overflow)的必要条件, 也就是说只有符号相同的两个整数相加才有可能产生溢出(overflow)问题. 这个可以这么理解: 你想要是两个符号不同的两个整数, 他们相加, 那么这个和的值的绝对值一定是比单个相加数和被相加数都小, 既然相加数和被相加数都能用现有整型变量表示, 那么两个不同整数的相加结果怎么样都可以用现有的整型范围的变量存储下来而不溢出(overflow). 所以结论： 只有符号相同的整数相加才有可能才生溢出(overflow).

整型相加溢出(overflow)的检测:
那么接下来的问题就是如何检测到溢出(overflow)的产生的, 更具体的, 给定两个整型, 比如int a, int b, 我们做加法a+b, 如何去判断这个相加的结果是正确结果还是说是溢出(overflow)的结果. 下面我们给出两种方法(后面我们会讨论方法二是更好的方法), 并且做出解释或者说不太严格的证明方法的正确性, 也就是为什么这么做就能保证溢出(overflow)的检测的正确性.

方法一, 计算相加的结果, 判断结果的符号, 两个正整数相加结果为负数, 或者两个负整数相加结果为正数, 那么就是溢出(overflow)了. 实现代码如下:

1
int addInt(int a, int b) {
2
    int res = a + b;
3
    if(a > 0 && b > 0 && res < 0) throw overflow_exception;
4
    if(a < 0 && b < 0 && res > 0) throw overflow_exception;
5
    return res;
6
}
这个方法的原理是这样, 计算机里面有符号整数是利用补码的形式表示的, 第一位是符号位, 0表示整数, 1表示负数. 我们拿一个字节的整型来举例, 一个字节的有符号数可以表示的范围就是-128 ~ 127, 那么两个一个字节的正整数相加的最大范围就是254, 那么其中128 ~ 254就是溢出(overflow)的值, 是不能用一个字节存储下的值, 这个值用一个字节表示的时候最高位是1, 在有符号整数系统里面这个值其实被当成了负数. 同理, 负数相加的时候最小可以到达-256, 根据补码的表示对应的正整数取反加1就是对应的补码, 那么对应的正整数的最高位是1, 现在取反以后就变成0， 也就是说两个比较大的负数相加的结果其实变成了正数. 这就是上述方法的理论基础.

方法二, 使用减法, 利用现有整型的最大或者最小极值减去某个加数(减法相当于变号, 从而保证没有溢出(overflow)的发生), 和另一个加数比较大小进行判断. 实现代码如下:

1
int addInt(int a, int b) {
2
    if(a > 0 && b > 0 && a > INT_MAX - b) throw overflow_exception;
3
    if(a < 0 && b < 0 && a < INT_MIN - b) throw overflow_exception;
4
    return a + b;
5
}
这个方法其实不用太多的解释, 简单的数学知识就能解释其中的原理, 由于减法保证了不会溢出(overflow), 又前面我们保证了两个数都是正整数, 所以形如 a > INT_MAX – b的判断是安全并且总是正确的. 而且这个检测方法的正确性可以通过移位就看得懂了, 不像方法一, 需要一定的计算机底层的知识才能解释说通.

方法一和方法二比较: 我自己一开始的时候思考利用方法一这样的结论去判断溢出(overflow), 但是我心里其实不放心, 因为方法一的前提是”两个正整数相加溢出的充要条件是符号位变成1, 也就是结果变成了负数”, 这样的结论或者事实对于我或者一般人来讲其实并不是那么的直观或者理所当然, 当然了我自己又用那个一个byte的例子试着去解释, 结论还是正确的,  所以方法一相比较方法二而言并不直观. 另一方面有说法说是溢出的时候结果其实不确定, 上面在方法一里面我们的分析只是理论上的分析, 编译器有可能做出相关的优化或者对溢出结果做出调整, 那么可能就出现未定义的行为了, 所以综上所述， 方法二应该是比较更为安全和合理并且更为直观的首选检测整数相加溢出(overflow)的方法.

更新: 感谢网友Stanley的留言, 提供了第三种方法的检测, 其实也就是方法一的bit operation版本, 通过位操作, 我们可以判断求和结果x是否与a和b还同号, 如果同时不同号(也就是sign bit不相同了), 那我们就相当于检测到了溢出. Stanley的版本稍微反了反, 我认为应该是下面这种情况才是溢出, 如有错误, 敬请指正. Thanks!

1
x = a + b;
2
if ((x^a) < 0 && (x^b) < 0)
3
{
4
    //overflow, do something
5
}
结束语:
本文主要讨论了如何判断整型相加溢出(overflow)的问题, 主要总结了整型相加溢出(overflow)的原因, 并给出了两种检测整型相加溢出(overflow)的方法, 方法一基于计算结果的正负, 方法二基于把加法转化为减法. 本文同时给出了两种方法的比较, 并且指出方法二应该是首选的检测方法.