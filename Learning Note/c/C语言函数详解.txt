 
前面说过，学习 C 语言有两个知识点是必须要学的，一个是函数，另一个是指针，这两个知识点是 C 语言的主体和核心。由此可见，学习函数的重要性，所以初学者一定要好好学。
什么是函数
第一，函数就是 C 语言的模块，一块一块的，有较强的独立性，可以相互调用，换句话说，C 语言中，一个函数里面可以调用 n 个函数，即大函数调用小函数，小函数又调用“小小”函数。这就是结构化程序设计，所以面向过程的语言又叫结构化语言。

第二，函数就是一系列 C 语句的集合，能完成某个特定的功能。需要该功能的时候直接调用该函数即可，不用每次都堆叠代码。需要修改该功能时，也只需要修改和维护这一个函数即可。
为什么需要函数
第一，将语句集合成函数的好处是方便代码重用。所谓“重用”，是指有一些代码的功能是相同的，操作是一样的，只不过针对的数据不一样，这时就可以将这种功能写成一个函数模块，以后用到这个功能时只需要调用这个函数模块就可以了，不需要再重复地编写同样的代码。这样可以解决大量同类型的问题，避免重复性操作。

第二，将语句集合成函数方便代码的维护。哪个功能出问题了，或者需要修改某个功能，那就只需要修改某个功能的函数就可以了。

所以，函数有利于程序的模块化。这实际上就是面向过程的思想。面向过程语言最基本的单位不是语句，而是函数。
库函数和自定义函数
前面各章中，程序大都只有一个主函数 main()，但是在实际编程中程序往往是由多个函数组成的。

C 语言不仅提供了极为丰富的库函数（几百个），还允许用户定义自己的函数。用户可以将自己的算法编成一个个相对独立的函数模块，然后通过调用来使用这些函数。在实际的C编程中用得最多的就是自己定义的函数。库函数只能提供一些基本的功能，我们所需要的大多数功能还是需要自己写。

不仅如此，在将来要学习的很多语言中，比如 Labview，这些公司在开发这些语言的时候就已经将所有需要用到的函数都模块化了，不再需要自己动手编写模块内部的程序。我们只需要调用这些模块编程即可，这样大大提高了编程的效率，简化了调试的难度。我们甚至不需要知道各个模块内部的程序到底是怎么编写的，我们只需要知道怎么用就行了。
函数的调用
可以说，C 程序的全部工作都是由各式各样的函数完成的。由于采用了函数模块式结构，所以C语言易于实现结构化程序设计，使程序的层次结构清晰，便于程序的编写、阅读和调试。

在 C 语言中，所有函数的定义，包括主函数 main 在内，都是“平行”的。也就是说，在一个函数的函数体内，不能再定义另一个函数，即不能嵌套定义。但是函数之间允许相互调用，也允许嵌套调用。习惯上将调用者称为主调函数，被调用者称为被调函数。函数还可以自己调用自己，称为递归调用。

此外，main 函数是主函数，它可以调用其他函数，但不允许被其他函数调用。C 程序的执行总是从 main 函数开始的（也是由 main 结束的），就算定义的函数放在 main 的前面，程序仍然从 main 开始执行。如果执行到函数调用则执行被调用的函数，完成函数调用后再返回到 main 函数继续往下执行，最后由 main 函数结束整个程序。一个 C 语言程序必须有且仅有一个主函数 main。


从形式上看，函数可分为两类：无参函数和有参函数。

所谓无参函数，是指在主调函数调用被调函数时，主调函数不向被调函数传递数据。无参函数一般用来执行特定的功能，可以有返回值，也可以没有返回值，但一般以没有返回值居多。

有参函数，是指在主调函数调用被调函数时，主调函数通过参数向被调函数传递数据。在一般情况下，有参函数在执行被调函数时会得到一个值并返回给主调函数使用。

有参函数是重点，我们主要介绍有参函数。
有参函数
定义有参函数的一般形式为：
函数类型 函数名(参数类型1 参数名1, 参数类型2 参数名2, …, 参数类型n 参数名n)
{
   声明部分
   语句部分
}

参数可以是一个，也可以是多个。下面给大家举一个例子：
# include <stdio.h>
int main(void)
{   
    int Max(int x, int y);  //对Max函数的声明, x、y称为形参
    int a = 1, b = 2;
    printf("max = %d\n", Max(a, b));  //a、b称为实参
    return 0;
}
//定义Max函数
int Max(int x, int y)
{
    int z;  //函数体中的声明部分
    if (x > y)  //下面是语句部分
    {
        z = x;
    }
    else
    {
        z = y;
    }
    return (z);  //返回z的值给主调函数使用
}
输出结果是：
max = 2

这个程序分两个部分，一个是主函数 main，另一个是自定义的函数 Max。Max 函数在主函数 main 的下面，它有两个参数，它的功能是求出 x 和 y 二者中的最大值。
形参和实参
下面先来讲一下“形参”和“实参”的概念。

在定义 Max 函数时，函数名 Max 后面括号中的参数 x、y 称为形式参数，简称形参。而在主调函数 main 中调用 Max 函数时，Max 函数名后面括号中的参数 a、b 称为实际参数，简称实参。实参可以是常量、变量或表达式，但它们必须要有确定的数值。在调用被调函数时将实参的值赋给形参。

在定义函数时，必须要指定形参的类型。实参与形参的个数必须相等，若不相等就是语法错误。此外，实参与形参的类型要相同或赋值兼容。最好是相同，这样不容易出错。如果不相同则实参按形参的类型转化，然后再送给形参。

在传递数据时，实参与形参是按顺序一一对应的。在 C 语言中，实参向形参的数据传递是“值传递”、单向传递，即只能由实参传给形参，不能由形参传回给实参。因此在执行被调函数时，形参的值如果发生改变，并不会改变主调函数中实参的值。

而且，在未出现函数调用时，形参并不占用内存中的存储单元。只有在发生函数调用时，函数 Max 中的形参才会被分配内存单元。调用结束后，形参所占的内存单元随之会被释放。

定义函数时，第一行“int Max(int x，int y）”称为函数首部。函数首部有两个数据类型，一个是“函数类型”，另一个是“参数类型”。函数名左边的类型叫“函数类型”，或“函数的返回值类型”。如果不想要返回值，那么这里就写 void。若使用 void 就不能有返回值，否则就是语法错误。需要注意的是，不能有返回值不代表不能有return语句：
return;

这也是正确的。只要 return 后面什么都不加就行，因为什么都不加也表示没有返回值。整个 return 语句全部都不写也可以。但是如果需要跳出被调函数的话就写上“return；”。

函数名后面括号中的数据类型是所传递的参数的类型。如果不希望定义的函数接收数据，或者说不想有参数传递进来，那么这里就写 void 或什么都不写，比如 int Max（void）。这就表示拒绝接受数据传递，这样实参的值就传不进来了。主函数 main 的首部都是这么写的：
int main(void)

即不允许有值传递进来。但是，如果被调函数的参数类型定义成 void，那么主调函数在调用它的时候就不能有实参，否则也是语法错误。

此外，如果函数名后面括号中什么都不写，那么默认的也是 void。

综上所述，函数首部的两个数据类型是不一样的。一个函数可以有返回值，也可以没有返回值；可以接收数据，也可以不接收数据。这个就是通过这两个数据类型控制的。


数组名作为函数参数传递，C语言数组作为函数参数传递详解

本节开始，先问大家一个问题：“要确定一个一维数组需要知道哪些信息？”一个是数组的首地址，另一个是数组的长度。这样就可以唯一地确定一个一维数组。因为数组是连续存放的，只要知道数组的首地址和数组的长度就能找到这个数组中所有的元素。

因此，要想通过实参和形参将一个数组从主调函数传到被调函数，那么只需要传递这两个信息即可。对于一维数组来说，其数组名就表示一维数组的首地址。所以只需要传递数组名和数组长度这两个参数就可以将数组从主调函数传入被调函数中。

当数组名作为函数的实参时，形参列表中也应定义相应的数组（或用指针变量），且定义数组的类型必须与实参数组的类型一致，如果不一致就会出错。但形参中定义的数组无须指定数组的长度，而是再定义一个参数用于传递数组的长度。所以在传递实参的时候，数组名和数组长度也只能用两个参数分开传递，而不能写在一起。因为即使写在一起，系统在编译时也只是检查数组名，并不会检查数组长度。所以数组长度要额外定义一个变量进行传递。

综上所述，当将数组从一个函数传到另一个函数中时，并不是将数组中所有的元素一个一个传过来（那样效率就太低了）。而是将能够唯一确定一个数组的信息传过来，即数组名（数组首地址）和数组长度。此时主调函数和被调函数操作的就是同一个数组。

下面来写一个程序：
# include <stdio.h>
int AddArray(int array[], int n);  //函数声明
int main(void)
{
    int a[] = {1, 2, 3, 4, 5, 6, 7, 8};
    int size = sizeof(a) / sizeof(a[0]);  /*数组所占内存总大小除以该数组中一个元素所占内存的大小, 从而得到数组元素的个数*/
    printf("sum = %d\n", AddArray(a, size));
    return 0;
}
int AddArray(int array[], int n)  //形参数组中不需要写长度
{
    int i, sum = 0;
    for (i=0; i<n; ++i)
    {
        sum += array[i];
    }
    return sum;
}
输出结果是：
sum = 36

再问大家一个问题：“前面讲过，当对数组名使用 sizeof 时可以求出整个数组在内存中所占的字节数。那么上面这个程序中，对被调函数 AddArray 中的数组 array 使用 sizeof 得到的值会是多少？”

有人会说，实参数组 a 占 32 字节，实参 a 传给形参 array，所以 array 也占 32 字节。但实际上，array 只占 4 字节。下面写一个程序看一下：
# include <stdio.h>
int AddArray(int array[]);  //函数声明
int main(void)
{
    int a[] = {1, 2, 3, 4, 5, 6, 7, 8};
    AddArray(a);
    return 0;
}
int AddArray(int array[])
{
    printf("sizeof(array) = %d\n", sizeof(array));
    return 0;
}
输出结果是：
sizeof(array) = 4

因为数组名做函数参数时，只是将实参数组的“首地址”传给了形参数组。此时被调函数 AddArray 中的数组 array 本质上是一个指针变量，里面存放的是主调函数中数组 a 的地址。指针变量也是一个变量类型。不同于前面所讲的其他变量类型，指针变量里面存放的不是一般的数据，而是地址。在 C 语言中，指针变量所占的字节数都是 4。所以对 array 使用 sizeof 求出的就是 4（但有些显示求出的可能是 8，这跟操作系统有关）。


变量按作用域可分为“局部变量”和“全局变量”。按存储方式又可分为“自动变量（auto）”、“静态变量（static）”、“寄存器变量（register）”和“外部变量（extern）”。注意，这里的“自动变量”不是指的“动态变量”。

什么叫“寄存器”？我们知道，内存条是用来存储数据的，硬盘也是存储数据的，而在 CPU 内部也有一些用来存储数据的区域，即寄存器。寄存器是 CPU 的组成部分，是 CPU 内部用来存放数据的一些小型存储区域，用来暂时存放参与运算的数据和运算结果。它同内存一样，只不过它能存储的数据要少得多。
局部变量
局部变量是定义在函数内部的变量，全局变量是定义在函数外部的变量。

局部变量只在本函数内有效，即只有在本函数内才能使用，在本函数外不能使用。如果局部变量定义在子函数中，那么只能在该子函数中使用。该子函数调用完后，系统为该子函数中的局部变量分配的内存空间就会被释放掉。

如果局部变量定义在主函数 main 中，那么只能在 main 函数中使用，main 函数执行结束后，系统为其中的局部变量分配的内存空间就会被释放掉。主函数也不能使用其他函数中定义的变量。所以不同函数中可以定义同名的变量，但它们所表示的是不同的对象，互不干扰。

在一个函数内部，可以在复合语句中定义变量，这些变量只在本复合语句中有效，离开本复合语句就无效，且内存单元随即被释放。所谓复合语句就是用大括号“{}”括起来的多个语句。下面给大家举一个例子：
# include <stdio.h>
int main(void)
{
    int a = 1, b = 2;
    {
        int c;
        c = a + b;
    }
    printf("c = %d\n", c);
    return 0;
}
编译结果：
error C2065: 'c' : undeclared identifier

这个程序有一个错误，编译结果显示：“变量 c 身份不明”，也就是说系统不认识 c 是什么。变量 a 和 b 在整个 main 函数中都有效，但变量 c 是在复合语句中定义的，所以只有在复合语句中才能使用。printf 在复合语句外，所以不能使用在复合语句中定义的变量 c。如果把 printf 放到复合语句中程序就编译成功了。
# include <stdio.h>
int main(void)
{
    int a = 1, b = 2;
    {
        int c;
        c = a + b;
        printf("c = %d\n", c);
    }
    return 0;
}
输出结果：
c = 3

我们在编程的时候，if 语句、for 循环、while 循环下面都有大括号。这就意味着如果局部变量是定义在这些大括号中的，那么就只能在这些大括号中使用。当这些大括号执行完之后，在其中定义的局部变量随即就会被释放。函数的形参也是局部变量，调用完该函数后，形参也会随之被释放。

所以局部变量的作用范围准确地说不是以函数来限定的，而是以大括号“{}”来限定的。在一个大括号中定义的局部变量就只能在这个大括号中使用，但因为每个函数体都是用大括号括起来的，而且我们一般也不会在函数体中的其他大括号中定义变量，所以习惯上就说“局部变量是定义在‘函数’内部的变量，只在本‘函数’内有效”。
全局变量
定义在函数内部的变量叫作局部变量，定义在函数外部的变量叫作全局变量。局部变量只能在该函数内才能使用；而全局变量可以被整个 C 程序中所有的函数所共用。它的作用范围是从定义的位置开始一直到整个 C 程序结束。所以根据定义位置的不同，全局变量的作用范围不同。

在一个函数中既可以使用本函数中的局部变量，也可以使用有效的全局变量。但需要注意的是，全局变量和局部变量命名决不能冲突。

前面说过，不同函数中可以定义同名的变量，但它们代表的是不同的对象，所以互不干扰，原因是局部变量的作用范围不同。但是全局变量和局部变量的作用范围可能有重叠，这时局部变量和全局变量的名字就不能定义成相同的了，否则就会互相干扰。如果在同一个作用范围内局部变量和全局变量重名，则局部变量起作用，全局变量不起作用。这样局部变量就会屏蔽全局变量。下面写一个程序验证一下：
# include <stdio.h>
int a = 10;  //定义一个全局变量
int main(void)
{   
    int a = 5;  //定义一个同名的局部变量
    printf("a = %d\n", a);
    return 0;
}
输出结果是：
a = 5

所以定义变量的时候局部变量和全局变量最好不要重名。此外，如果局部变量未初始化，那么系统会自动将“–858993460”放进去（VC++6如此）。但如果全局变量未初始化，那么系统会自动将其初始化为 0。它们的这个区别主要源自于它们存储空间的不同。局部变量是在栈中分配的，而全局变量是在静态存储区中分配的。只要是在静态存储区中分配的，如果未初始化则系统都会自动将其初始化为 0。下面来写一个程序验证一下：
# include <stdio.h>
int a;  //定义一个全局变量
int main(void)
{   
    printf("a = %d\n", a);
    return 0;
}
输出结果是：
a = 0

设置全局变量的作用是增加函数间数据联系的渠道。因为全局变量可以被多个函数所共用，这样就可以不通过实参和形参向被调函数传递数据。所以利用全局变量可以减少函数中实参和形参的个数，从而减少内存空间传递数据时的时间消耗。但是除非是迫不得已，否则不建议使用全局变量。
为什么不建议使用全局变量
1) 全局变量在程序的整个执行过程中都占用存储单元，而局部变量仅在需要时才开辟存储单元。

2) 全局变量降低了函数的通用性，因为函数在执行时要依赖那些全局变量。我们将一个功能编写成函数，往往希望下次遇到同样功能的时候直接复制过去就能使用。但是如果使用全局变量的话，这个函数和全局变量有联系，就不好直接复制过去了，还要考虑这个全局变量的作用。即使把全局变量也复制过去，但是如果该全局变量和其他文件中的变量重名的话，程序就会出问题。而且如果该全局变量和其他函数也有关联的话，程序也会出问题。所以全局变量降低了程序的可靠性和通用性。

在程序设计中，划分模块时要求模块的“内聚性”强、与其他模块的“关联性”弱。即模块的功能要单一，不要把许多互不相干的功能放到一个模块中，与其他模块间的相互影响要尽量小。而使用全局变量是不符合这个原则的。一般要求把C程序中的函数做成一个封闭体，除了可以通过“实参–形参”的渠道与外界发生联系外，没有其他渠道。这样的程序可移植性好，可读性强，而使用全局变量会使程序各函数之间的关系变得极其复杂。

3) 过多的全局变量会降低程序的清晰性。人们往往难以清楚地判断出每个时刻各个全局变量的值，原因是每个函数在执行的时候都有可能改变全局变量的值。这样程序就很容易出错，而且逻辑上很乱。因此要限制全局变量的使用，不到万不得已，不要使用全局变量。

4) 如果在同一个程序中，全局变量与局部变量同名，则在局部变量的作用范围内，全局变量就会被“屏蔽”，即它不起作用。
自动变量（auto）
前面定义的局部变量其实都是 auto 型，只不过 auto 可以省略，因为省略就默认是 auto 型。
静态变量（static）
static 还是比较重要的，static 可以用于修饰局部变量，也可以用于修饰全局变量。下面分别介绍一下。

用 static 修饰过的局部变量称为静态局部变量。局部变量如果不用 static 进行修饰，那么默认都是 auto 型的，即存储在栈区。而定义成 static 之后就存储在静态存储区了。

前面说过，存储在静态存储区中的变量如果未初始化，系统会自动将其初始化为 0。用 static 修饰过的局部变量也不例外，下面写一个程序验证一下：
# include <stdio.h>
int main(void)
{   
    static int a;
    printf("a = %d\n", a);
    return 0;
}
输出结果是：
a = 0

静态存储区主要用于存放静态数据和全局数据。存储在静态存储区中的数据存在于程序运行的整个过程中。所以静态局部变量不同于普通局部变量，静态局部变量是存在于程序运行的整个过程中的。下面来写一个程序看一下：
# include <stdio.h>
void Increment(void);  //函数声明
int main(void)
{
    Increment();
    Increment();
    Increment();
    return 0;
}
void Increment(void)
{
    static int x = 0;
    int y = 0;
    ++x;
    ++y;
    printf("x = %d, y = %d", x, y);
    printf("\n");
    return;
}
输出结果是：
x = 1, y = 1
x = 2, y = 1
x = 3, y = 1

我们看到，变量 x 是静态局部变量，而变量 y 是普通的局部变量。从输出结果可以看出，y 的值一直都是 1，而 x 的值是变化的。这是因为变量 y 是普通的局部变量，每次函数调用结束后就会被释放；而变量 x 是用 static 修饰的，所以它是静态局部变量，即使函数调用结束它也不会被释放，而是一直存在于程序运行的整个过程中，直到整个程序运行结束后才会被释放。这就相当于全局变量，但它不是全局变量，静态局部变量仍然是局部变量，仍然不能在它的作用范围之外使用。

有人可能会问，如果静态局部变量在函数调用结束后也不释放，那函数每调用一次变量 x 不就重新定义一次，并重新赋值一次了吗？

静态局部变量仅在第一次函数调用时定义并初始化，以后再次调用时不再重新定义和初始化，而是保留上一次函数调用结束后的值。也就是说“static int x=0；”这条语句只会执行一次。

下面再来看全局变量。全局变量默认都是静态的，都是存放在静态存储区中的，所以它们的生存周期固定，都是存在于程序运行的整个过程中。所以一个变量生命周期的长短本质上是看它存储在什么地方。存储在栈区中的变量，在函数调用结束后内存空间就会被释放；而存储在静态存储区中的变量会一直存在于程序的整个运行过程中。这就是局部变量和全局变量生命周期不同的原因。

虽然全局变量本身就是存储在静态存储区的，但它仍然可以用 static 进行修饰。而且修饰和不修饰是有区别的。用 static 修饰全局变量时，会限定全局变量的作用范围，使它的作用域仅限于本文件中。这个是使用 static 修饰全局变量的主要目的。

那么，不用 static 修饰，全局变量不也是只能在本文件中使用吗？这么说不完全对，因为虽然全局变量的作用范围不会自己主动作用到其他文件中，但不代表其他文件不会使用它。如果不用 static 进行修饰，那么其他文件只需要用 extern 对该全局变量进行一下声明，就可以将该全局变量的作用范围扩展到该文件中。但是当该全局变量在定义时用static进行修饰后，其他文件不论通过什么方式都不能访问该全局变量。

而且如果一个项目的多个 .c 文件中存在同名的全局变量，那么在编译的时候就会报错，报错的内容是“同一个变量被多次定义”。但是如果在这些全局变量前面都加上 static，那么编译的时候就不会报错。因为用 static 修饰后，这些全局变量就只属于各自的 .c 文件了，它们是相互独立的，所以编译的时候就不会发生冲突而产生“多次定义”的错误。所以使用 static 定义全局变量是非常有用的，因为当一个项目中有很多文件的时候，重名不可避免。这时候只要在所有的全局变量前面都加上 static 就能很好地解决这个问题。定义全局变量时用 static 进行修饰可以大大提高代码的质量。

总结：
1) 用 static 修饰后的局部变量称为静态局部变量。因为局部变量在函数调用结束后就会被释放，所以如果不希望它被释放的话，就在定义时用 static 对它进行修饰。如：
static int a;
2) 定义成 static 型的变量是存放在静态存储区中的，在程序的整个运行过程中都不会被释放。这跟全局变量很像，但它不是全局变量。静态局部变量仍然是局部变量，只不过它的生命周期改变了，但作用范围并没有改变，所以其他函数仍然不能使用它。它之所以跟全局变量很像是因为它们都是存放在静态存储区中，所以它们都存在于程序运行的整个过程中。

3) 如果把局部变量定义成 static 型，那么在程序的整个运行过程中，它只在编译时赋初值一次，以后每次调用函数时不会再重新给它赋值，而是保留上一次函数调用结束时的值。如果定义静态局部变量时没有初始化的话，那么在编译时系统会自动给它赋初值 0（对数值型变量）或空字符 '\0'（对字符变量）。

4) 但是静态局部变量跟全局变量一样，长期占用内存不放，而且降低了程序的可读性，当调用次数过多时往往弄不清楚其当前值是什么。所以若非必要，不要过多使用静态局部变量。

5) 对全局变量使用 static 进行修饰是 static 非常重要的用法。如果不用 static 对全局变量进行修饰，那么其他文件只需要使用 extern 对该全局变量进行声明就可以直接使用该全局变量。但是当用 static 进行修饰后，即使其他文件用 extern 对它进行声明也不能使用它。这种用法可以有效防止并解决不同文件中全局变量重名的问题。
寄存器变量（register）
无论是存储在静态存储区中还是存储在栈区中，变量都是存储在内存中的。当程序用到哪个变量的时候，CPU 的控制器就会发出指令将该变量的值从内存读到 CPU 里面。然后 CPU 再对它进行处理，处理完了再把结果写回内存。

但是除了内存可以存储数据之外，CPU 内部也有一些用来存储数据的区域，这就是寄存器。寄存器是 CPU 的组成部分，是 CPU 内部用来存放数据的小型存储区域，用来暂时存放参与运算的数据和运算结果。与内存相比，寄存器所能存储的数据要小得多，但是它的存取速度要比内存快很多。

那为什么寄存器的存取速度比内存快呢？最主要的原因是因为它们的硬件设计不同。计算机中硬件运行速度由快到慢的顺序是：
寄存器>缓存>内存>固态硬盘>机械硬盘

为了提高代码执行的效率，可以考虑将经常使用的变量存储到寄存器中。比如循环变量和循环体内每次循环都要使用的局部变量。这种变量叫作寄存器变量，用关键字 register 声明。如
register  int  a;
但是需要注意的是，register 关键字只是请求编译器尽可能地将变量存储在 CPU 内部的寄存器中，但并不一定。因为我们说过，寄存器所能存储的数据是很少的，所以如果寄存器已经满了，那么即使你用 register 进行声明，数据仍然会被存储到内存中。而且需要注意的是，并不是所有的变量都能定义成寄存器变量，只有局部变量才可以。或者说寄存器变量也是一个局部变量，在函数调用结束后就会被释放。

register 看起来很有用，但是要跟大家说的是，这个修饰符现在已经不用了。现在的编译器都比较智能化，它会自动分析，即使变量定义的是 auto 型（默认的），但如果它发现这个变量经常使用，那么它也会把这个变量放到寄存器中。同样，即使定义成 register 型，但如果寄存器中没地方存放，那么它也会把这个变量放到内存中。

这时有些人就提出一个疑问：“既然寄存器速度那么快，那么为什么不把计算机的内存和硬盘都改成寄存器？我们前面说过，寄存器之所以比内存速度快，最主要的原因是因为它们的硬件设计不同。从硬件设计的角度来看，寄存器的制作成本要比内存高很多！而且寄存器数量的增加对 CPU 的性能也提出了极高的要求，而这往往是很难实现的。
外部变量（extern）
extern 变量是针对全局变量而言的。通过前面了解到，全局变量都是存放在静态存储区中的，所以它们的生存期是固定的，即存在于程序的整个运行过程中。但是对于全局变量来说，还有一个问题尚待解决，就是它的作用域究竟从什么位置起，到什么位置结束。作用域是包括整个文件范围，还是只包括文件中的一部分？是在一个文件中有效，还是在程序的所有文件中都有效？

一般来说，外部变量是在函数的外部定义的全局变量，它的作用域是从变量的定义处开始，到本程序文件的末尾结束。在此作用域内，全局变量可以被程序中各个函数所引用。但是有时程序设计人员希望能扩展全局变量的作用域，如以下几种情况：

1) 在一个文件内扩展全局变量的作用域

如果全局变量不在文件的开头定义，其有效的作用范围只限于定义处到文件结束。在定义点之前的函数不能引用该全局变量。如果出于某种考虑，在定义点之前的函数需要引用该全局变量，那么就在引用之前用关键字extern对该变量作“外部变量声明”，表示将该全局变量的作用域扩展到此位置，比如：
extern  int  a;
有了此声明就可以从“声明”处起，合法地使用该全局变量了。

2) 将外部变量的作用域扩展到其他文件

一个 C 程序可以由一个或多个 .c 文件组成。如果程序只由一个 .c 文件组成，那么使用全局变量的方法前面已经介绍了。如果程序由多个 .c 文件组成，那么如何在一个文件中引用另一个文件中定义的全局变量呢？

假如在 1.c 中定义了全局变量“int a=10；”，如果 2.c 和 3.c 也想使用这个变量 a，而我们不能在 2.c 和 3.c 中重新定义这个 a，否则在编译链接时就会出现“重复定义”的错误。正确的做法是在 2.c 和 3.c 中分别用 extern 对 a 作“外部变量声明”，即在 2.c 和 3.c 中使用 a 之前作如下声明：

这样在编译和链接时，当编译器在 2.c 中遇到变量 a 的声明时就会知道它有“外部链接”，就会从其他文件中寻找a的定义，并将在另一文件中定义的全局变量a的作用范围扩展到本文件中。这样在本文件中也可以合法地使用全局变量 a 了。但是现在问大家一个问题：“以 2.c 为例，如果在 2.c 中对 a 进行多次声明，即写多个“externinta；”，那么程序会不会有错？”答案是不会，C 语言中是允许多次声明的，但有效的只有一个。

与全局变量一样，同一个项目的不同 .c 文件中也不能定义重名的函数。如果 2.c 和 3.c 想要使用 1.c 中定义的函数，那么也只需要在 2.c 和 3.c 中分别对该函数进行声明就可以了。即直接把 1.c 中对函数的声明拷贝过来就行了。

与全局变量不同的是，它的前面不用加 extern。因为对于函数而言，默认就是 extern，所以声明时前面的 extern 可以省略。此外在实际编程中，我们一般不会直接把 1.c 中某个函数的声明拷贝到 2.c 和 3.c 中，而是把该声明写在一个 .h 头文件中，然后分别在 2.c 和 3.c 中用 #include 包含该头文件即可。如果不用头文件当然也可以，但此时 2.c 和 3.c 中都要写该函数的声明，这样如果要修改的话就都要修改。而如果写在头文件中，要修改的话就只需要改头文件中的内容就可以了。

关于头文件后面还会专门介绍。此外，同一个 .c 文件中对同一个函数进行多次声明也是允许的，但它们起作用的只有一个。


函数及其使用注意事项，C语言函数及使用注意事项详解
 
在 C 语言中，函数是构成 C 程序的基本功能单元，它是一个能够独立完成某种功能的程序块，其中封装了程序代码和数据，实现了更高级的抽象和数据隐藏。这样编程者只需要关心函数的功能和使用方法，而不必关心函数功能的具体实现细节。

一个 C 程序由一个主函数（main 函数）与多个函数构成。其中，主函数 main()  可以调用任何函数，各函数之间也可以相互调用，但是一般函数不能调用主函数。所有函数都是平行、独立的，不能嵌套定义，但可以嵌套调用。本章将重点论述函数设计的一些常用建议，其中包括函数的规划、内部实现、参数与返回值等。
理解函数声明
谈到函数声明，就不得不说这样一个例子：有一段程序存储在起始地址为 0 的一段内存上，要调用这段程序，该如何去做？答案如下：
(*(void(*) ()) 0)()；

恐怕像这样的表达式，无论是新程序员，还是经验丰富的老程序员，都会感到不寒而栗。然而，构造这类表达式其实只有一条简单的规则：按照使用的方式来声明。

接下来看如下两个简单的声明示例：
float f();
float *pf;
在上面的代码中，很显然，f 是一个返回值为浮点类型的函数；而 pf 则是一个指向浮点数的指针。如果将它们简单地组合起来，就可以得到如下两种声明方式：
float *f1();
float (*f2)();
上面两者的区别在于：因为“()”结合优先级高于“*”，也就是说“*f1()”等价于“*(f1())”，即f1是一个函数，它返回值类型为指向浮点数的指针；同理，f2 是一个函数指针，它所指向的函数的返回值为浮点类型。

在这里需要特别注意的是，一旦知道了如何声明一个给定类型的变量，该类型的类型转换符就很容易得到：只需要去掉声明中变量名和声明末尾的分号，再将剩余的部分用一个括号整个“封装”起来，即：
float (*f2)();
因为 f2 是一个指向返回值为浮点类型的函数的指针，因此，该类型的类型转换符如下：
(float (*)())

即它表示一个“指向返回值为浮点类型的函数的指针”的类型转换符。

好了，现在继续分析上面的例子：
(*(void(*) ())0)();

在这里假定变量 fp 是一个函数指针，显然“*fp”就是该指针所指向的函数。当然，“(*fp)()”就是调用该函数的方式（在 ANSI C 标准中，允许程序员简写为“fp()”这种形式）。在“(*fp)()”中，“*fp”两侧的括号非常重要，因为“()”结合优先级高于“*”。如果“*fp”两侧没有括号，那么“*fp()”实际上与“*(fp())”的含义完全一致，ANSI C 把它作为“*((*fp)())”的简写形式。

根据问题描述，可以知道 0 是这个函数的入口地址，也就是说，0 是一个函数的指针。结合上面的“(*fp)()”，问题中的函数调用可以写成如下形式：
(*0)();

大家都知道，函数指针变量不能是一个常数，很显然上式并不能生效。因此，上式中的0必须被转化为函数指针，一个指向返回值为 void 类型的函数的指针。也就是说，需要将 fp 的声明修改成如下形式：
void (*fp)();

这样，就可以得到该类型的类型转换符：
(void (*)())

现在将常数 0 转型为“指向返回值为 void 的函数的指针”类型就可以写成如下形式：
(void (*)())0

最后，使用“(void(*)())0”来替换“(*fp)(0”中的fp或“(*0)()”中的0，就可以很简单地得到下面的表达式：
(*(void (*)())0)();

为了便于大家理解，在这里继续对“(*(void(*)())0)()”做如下 4 点说明：
对于“void(*)()”，可以很简单地看出这是一个函数指针类型，这个函数没有参数（参数为空），并且也没有返回值（返回值为 void）；
对于“(void(*)())0”，这里将 0 强制转换为函数指针类型，其中 0 是一个地址，也就是说，一个函数存在首地址为 0 的一段区域内；
对于“(*(void(*)())0)”，这里取 0 地址开始的一段内存中的内容，其内容就是保存在首地址为 0 的一段区域内的函数；
对于“(*(void(*)())0)()”，很简单，这当然就是函数调用了。
理解函数原型
在 ANSI C 标准中，允许采用函数原型方式对被调用的函数进行说明，其主要作用就是利用它在程序的编译阶段对调用函数的合法性进行全面检查。

函数原型能告诉编译器函数的名称，函数有多少个参数，每个参数分别是什么类型，函数的返回类型又是什么等。当函数被调用时，编译器可以根据这些信息判断实参个数与类型是否正确，函数的返回类型是否正确等。函数原型能让编译器及时发现函数调用时存在的语法错误。示例代码如下：
/*函数原型*/
char *Memcopy(char *dest, const char *src, size_t size);
/*函数定义*/
char *Memcopy(char *dest, const char *src, size_t size)
{
    assert((dest != NULL) && (src != NULL));
    char *retAddr = dest;
    while (size --> 0)
    {
            *(dest++) = *(src++);
    }
    return retAddr;
}
在上面的代码中，当调用 Memcopy() 函数时，编译器就会检查调用函数的实参是不是 3 个？每个参数的类型是否匹配？函数的返回类型是否正确？如果编译程序发现函数的调用或定义与函数原型不匹配，编译程序就会报告出错或发出警告消息。

在一般情况下，当被调用函数的定义出现在主调用函数之后时，应必须在调用语句之前给出函数原型。如果在被调用之前没有给出函数原型，则编译器会将第一次遇到的该函数定义作为函数的声明，并将函数返回值类型默认为int型。

如果这样，当函数返回值类型为整型时，是否无须给出函数原型呢？很显然，这种偷懒的方法将使得编译器无法对实参和形参进行匹配检查。若调用函数时参数使用不当，编译器也不会再给出善意的提醒，你也许会得意于程序的安全通过，但你很可能将面临类型不匹配所带来的系统崩溃的危险。

总之，在源文件中说明函数原型提供了一种检查函数是否被正确引用的机制。同时，目前许多流行的编译程序都会检查被引用的函数的原型是否已在源文件中说明过，如果没有，就会发出警告消息。
尽量使函数的功能单一
在程序的函数设计中，我们所要遵循的首要设计原则就是“函数功能单一”。也就是说，一个函数应该只能够完成一件事情，并且只能够完成它自己的任务。函数功能应该越简单越好，尽量避免设计多用途、面面俱到、多功能集于一身的复杂函数。

当然，如果你有一个概念上简单的函数（这里所谓的“简单”是 simple 而不是 easy），它恰恰包含着一个很长的 case 语句，这样你就不得不为这些不同的情况准备不同的处理，那么这样的长函数是允许的。但是，如果你有一个复杂的函数，并且一般程序员在没有详细文档的情况下很难读懂这个函数，那么应该努力简化这个函数的功能与代码，适当拆分这个函数的功能，使用一些辅助函数，给它们取描述性的名字。

与此同时，人类的大脑一般能够同时记住 7 个不同的东西，超过这个数目就会犯糊涂。因此，对于函数的局部变量的数目也应该尽量减少，一般情况下最多 5~10 个。

下面我们来看一个函数的设计示例。
#include <stdio.h>
#include <stdlib.h>
typedef int ElementType;
typedef struct node
{
    ElementType data;
    struct node *next;
}StackNode, *LinkStack;
void InvertedSequence(int num)
{
    int i=0;
    int result=0;
    LinkStack ls;
    // 初始化
    ls = (LinkStack)malloc(sizeof(StackNode));
    ls->next = NULL;
    printf("数据输入为：\n");
    for(i=0; i<num; i++)
    {
        // 入栈
        StackNode *temp;
        temp = (StackNode *)malloc(sizeof(StackNode));
        if(temp != NULL)
        {
            temp->data = i;
            temp->next = ls->next;
            ls->next = temp;
            printf("%d ",i);
        }
    }
    printf("\n数据输出为：\n");
    while (ls->next != NULL)
    {
        // 出栈
        StackNode *temp = ls->next;
        result = temp->data;
        ls->next = temp->next;
        free(temp);
        printf("%d ",result);
    }
    printf("\n");
}
int main(void)
{
    InvertedSequence(20);
    return 0;
}
在 InvertedSequence(int num)  方法中，我们实现了链栈的常用操作，即包括初始化、入栈与出栈等操作，其运行结果为：

数据输入为：
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
数据输出为：
19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0

很显然，代码中的 InvertedSequence(int num) 多功能函数不仅很可能使理解、测试、维护函数等变得困难，并且也会使函数不具有好的可复用性，如果在后续的代码中遇到类似的功能需求，又将需要重写此功能代码。由此可见，虽然这里的 InvertedSequence(int num) 函数满足了程序功能的需要，但是它却违反了函数的功能单一原则。

因此，根据函数的功能单一原则，我们应该将该函数的相关链栈操作独立进行设计，这样不仅能够使函数的功能变得简单，而且能够很好地保证函数有良好的扇入和扇出比例，特别是公用模块或底层模块中的函数一定要具有较大的扇入才能有效提高代码的可复用性。改正后的示例如代码为：
typedef int BOOL;
#define TRUE 1
#define FALSE 0
#define STACK_SIZE 100
typedef int ElementType;
typedef struct node
{
    ElementType data;
    struct node *next;
}StackNode,*LinkStack;
// 初始化
void InitStack(LinkStack ls)
{
    ls->next = NULL;
}
// 是否为空
BOOL IsEmpty(LinkStack ls)
{
    if(ls->next == NULL)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}
// 入栈
BOOL Push(LinkStack ls, ElementType element)
{
    StackNode *temp;
    temp = (StackNode *)malloc(sizeof(StackNode));
    if(temp == NULL)
    {
        return FALSE;
    }
    temp->data = element;
    temp->next = ls->next;
    ls->next = temp;
    return TRUE;
}
// 出栈
BOOL Pop(LinkStack ls, ElementType *element)
{
    if(IsEmpty(ls))
    {
        return FALSE;
    }
    else
    {
        StackNode *temp = ls->next;
        *element = temp->data;
        ls->next = temp->next;
        free(temp);
        return TRUE;
    }
}
void InvertedSequence(int num)
{
    int i=0;
    int result=0;
    LinkStack ls;
    ls = (LinkStack)malloc(sizeof(StackNode));
    // 初始化
    InitStack(ls);
    printf("数据输入为：\n");
     for(i=0; i<num; i++)
    {
        // 入栈
        Push(ls,i);
        printf("%d ",i);
    }
    printf("\n数据输出为：\n");
    while (!IsEmpty(ls))
    {
        // 出栈
        Pop(ls,&result);
        printf("%d ",result);
    }
    printf("\n");
}
现在，通过对比以上两端代码，可以很容易看出，后段代码不仅简单易读、易维护，而且其函数也具有更好的可复用性。严格遵循函数的功能单一原则，这样不但能够让你更好地命名函数，也使理解和阅读代码变得更加容易。

如果遇到一个特殊的情况不得不打破这个原则，可以停下来，思考一下是不是自己对这个“特殊情况”的理解还不够深。函数应该很精确地执行一件事且只执行这一件事，明确函数功能（一个函数仅完成一件事情），精确（而不是近似）地实现函数设计。
避免把没有关联的语句放在一个函数中
在代码编写中，我们时常会为了提高代码的可复用性而刻意地将不同函数中使用的相同代码语句提出来，抽象成一个新的函数。当然，如果这些代码的关联度较高，并且完成同一个功能，那么这种抽象是合理的。但是，如果仅仅是为了提高代码的可复用性，把没有任何关联的语句放在一起，就会给以后的代码维护、测试及升级等造成很大的不便，同时也使函数的功能不明确。示例代码如下：
void Init (void)
{
    /* 初始化矩形的长与宽 */
    Rect.length = 0；
    Rect.width = 0；
    /* 初始化“点”的坐标 */
    Point.x = 0；
    Point.y = 0；
}
很显然，上面的函数 Init(void) 设计是不合理的，因为矩形的长、宽与点的坐标基本没有任何关联。因此，我们应该将其抽象为如下两个函数：
/* 初始化矩形的长与宽 */
void InitRect(void)
{
    Rect.length = 0;
    Rect.width = 0;
}
/* 初始化“点”的坐标 */
void InitPoint(void)
{
    Point.x = 0;
    Point.y = 0;
}
函数的抽象级别应该在同一层次
先来看下面一段示例代码：
void Init( void )
{
    /*本地初始化*/
     ...
     InitRemote();
}
void InitRemote(void)
{
    /*远程初始化*/
     ...
}
从表面上看，上面的 Init(void) 函数主要完成本地初始化与远程初始化工作，在其功能实现上没什么不妥之处。但从设计观点看，却存在着一定的缺陷。从 Init(void) 函数中，我们可以看出，本地初始化与远程初始化的地方是相当的。因此，如果远程初始化作为独立的函数存在，那么本地初始化也应该作为独立的函数存在。

很显然，上面的 Init(void) 函数将本地初始化直接运行在本函数内部，而将远程初始化封装在一个独立的函数内，并在这里进行调用。这种设计是不妥的，两个函数的抽象级别应该在同一层次，如下面的示例代码所示：
void Init(void)
{
    InitLocal();
    InitRemote();
}
void InitLocal(void)
{
    /*本地初始化*/
     ...
}
void InitRemote(void)
{
    /*远程初始化*/
     ...
}
尽可能为简单功能编写函数
有时候，我们需要用函数去封装仅用一两行代码就可完成的功能。对于这样的函数，单从代码量上看，好像没有什么封装的必要。但是，用函数可使其功能明确化、具体化，从而增加程序可读性，并且也方便代码的维护与测试。示例代码如下：
int Max(int x,int y)
{
    return(x>y？x：y);
}
int Min(int x,int y)
{
    return(x<y？x：y);
}
当然，也可以使用宏来代替上面的函数，代码如下：
#define MAX(x，y) (((x) > (y)) ？ (x) : (y))
#define MIN(x，y) (((x) < (y)) ？ (x) : (y))
在 C 程序中，我们可以适当地用宏代码来提高执行效率。宏代码本身不是函数，但使用起来与函数相似。预处理器用复制宏代码的方式代替函数调用，省去了参数压栈、生成汇编语言的 CALL 调用、返回参数、执行 return 等过程，从而提高了运行速度。

但是，使用宏代码最大的缺点就是容易出错，预处理器在复制宏代码时常常产生意想不到的边际效应。因此，尽管看起来宏要比函数简单得多，但还是建议使用函数的形式来封装这些简单功能的代码。
避免多段代码重复做同一件事情
在源文件中，如果存在着多段代码重复做同一件事情，那么很可能在函数的划分上存在着一定的问题。若此段代码各语句之间有实质性关联并且是完成同一项功能的，那么可以考虑把此段代码抽象成一个新的函数。

示例代码如下：
/*希尔排序法*/
void ShellSort(int v[],int n)
{
    int i,j,gap,temp;
    for(gap=n/2;gap>0;gap /= 2)
    {
        for(i=gap;i<n;i++)
        {
            for(j=i-gap;(j >= 0) && (v[j] > v[j+gap]);j -= gap )
            {
                temp=v[j];
                v[j]=v[j+gap];
                v[j+gap]=temp;
            }
        }
    }
}
/* 冒泡排序法 */
void BubbleSort (int v[],int n)
{
    int i,j,temp;
    for(j=0;j<n;j++)
    {
        for(i=0;i<(n-(j+1));i++)
        {
            if(v[i]>v[i+1])
            {
                temp=v[i];
                v[i]=v[i+1];
                v[i+1]=temp;
            }
        }
    }
}
在上面的示例代码中，函数 ShellSort(int v[],int n) 与函数 BubbleSort(int v[],int n) 分别实现了希尔排序与冒泡排序的功能。仔细观察这两个简单的排序函数，不难发现，无论是 ShellSort(int v[],int n) 函数，还是 BubbleSort(int v[],int n) 函数，都会执行交换操作。因此，我们可以将它们的交换操作代码抽取出来，独立成一个新的函数，示例代码如下：
/*交换*/
void Swap(int *i, int *j)
{
    int temp;
    temp=*i;
    *i=*j;
    *j=temp;
}
这样，抽取出 Swap(int*i,int*j) 函数之后，不仅能够避免不必要的代码重复，便于以后维护与升级代码，而且能够使我们的代码具有更大的复用价值。

现在，我们可以直接在上面的排序函数中或其他任何需要交换操作的函数中调用这个交换函数 Swap(int*i,int*j)，示例代码如下：
/*希尔排序法*/
void ShellSort(int v[],int n)
{
    int i,j,gap;
    for(gap=n/2;gap>0;gap /= 2)
    {
        for(i=gap;i<n;i++)
        {
            for(j=i-gap;(j >= 0) && (v[j] > v[j+gap]);j -= gap )
            {
                Swap(&v[j],&v[j+gap]);
            }
        }
    }
}
/* 冒泡排序法 */
void BubbleSort (int v[],int n)
{
    int i,j;
    for(j=0;j<n;j++)
    {
        for(i=0;i<(n-(j+1));i++)
        {
            if(v[i]>v[i+1])
            {
                Swap(&v[i],&v[i+1]);
            }
        }
    }
}
在调用函数时，必须对返回值进行判断
在程序设计中，调用一个函数之后，必须检查函数的返回值，以决定程序是继续应用逻辑处理还是进行出错处理。同时，这也带来了一系列设计问题：如果出错了怎么办？错误如何表达？该如何定义出错处理的准则或机制？

很显然，如果一个项目没有一种有效的方法表达一个错误，就会出现对于出错处理的混乱状况。与此同时，在大型项目中，如果出现错误，仅仅通过C库中已经定义的那么几个错误码并不能有效表达应用错误。因此，我们需要针对不同的错误采用完全不同的出错处理方法，设计出适合自己的出错处理机制。
尽量减少函数本身或者函数间的递归调用
递归作为一种算法在程序设计语言中被广泛应用，简单地讲，递归就是函数调用自己，或者在自己函数调用的下级函数中调用自己。示例代码如下：
long fab(const int index)
{
    if(index == 1 || index == 2)
    {
        return 1;
    }
    else
    {
        return fab(index-1)+fab(index-2);
    }
}
递归之所以能实现，是因为函数的每个执行过程都在堆栈中有自己的形参和局部变量的副本，而这些副本和函数的其他执行过程毫不相干。所以递归函数有一个最大的缺陷，那就是增加了系统的开销。因为每调用一个函数，系统就需要为函数准备堆栈空间用于存储参数信息，如果频繁进行递归调用，系统需要为其开辟大量的堆栈空间。

与此同时，递归调用特别是函数间的递归调用，会大大影响程序的可理解性。因此，我们在程序设计中应该尽量使用其他算法来替代递归算法。下面的示例演示了如何使用迭代算法来替代递归算法：
long fab(const int index)
{
    if(index == 1 || index == 20)
    {
        return 1;
    }
    else
    {
        long l1 = 1L;
        long l2 = 1L;
        long l3 = 0;
        /*迭代求值*/
        for(int i = 0;i < index-2;i ++)
        {
            l3 = l1 + l2;
            l1 = l2;
            l2 = l3;
        }
        return l3;
    }
}
在很多时候，因为递归需要系统堆栈，所以空间消耗要远比非递归代码大很多。而且，如果递归深度太大，可能会导致系统资源不够用。因此大家都有这样一个观点：能不用递归算法就不用递归算法，递归算法都可以用迭代算法来代替。

从某种程度上讲，递归算法确实是方便了程序员，而难为了机器。递归可以通过数学公式很方便地转换为程序，其优点就是易理解，容易编程。但递归是用堆栈机制实现的，每深入一层，都要占去一块堆栈数据区域。因此，对嵌套层数深的一些算法，递归就会显得力不从心，空间上也会以内存崩溃而告终。同时，因为递归带来了大量的函数调用，这增加了许多额外的时间开销。

在理论上，虽然递归算法和迭代算法在时间复杂度方面是等价的（在不考虑函数调用开销和函数调用产生的堆栈开销）。但在实际开发环境中上，递归算法确实要比迭代算法效率低许多。但是不得不注意的是，虽然迭代算法比递归算法在效率上要高一些（它的运行时间只会因循环次数增加而增加，没什么额外开销，空间上也没有什么额外的增加），但我们又不得不承认，将递归算法转换为迭代算法的代价通常都是比较高的，而且，并不是所有的递归算法都可以转换为迭代算法。同时，迭代算法也存在着不容易理解，编写复杂问题时困难等问题。

因此，“能不用递归算法就不用递归算法，递归算法都可以用迭代算法来代替”这样的理解，还是应该辩证看待，切不能一概而论。一般而言，采用递归算法需要的前提条件是当且仅当一个存在预期的收敛时，才可采用递归算法；否则，就不能使用递归算法。


值传递和地址传递，C语言函数传参方式详解

在 C 语言中，函数的参数传递方式有两种：值传递与地址传递。下面分别介绍这两种传递形式。
值传递
这种方式使用变量、常量、数组元素作为函数参数，实际是将实参的值复制到形参相应的存储单元中，即形参和实参分别占用不同的存储单元，这种传递方式称为“参数的值传递”或者“函数的传值调用”。

值传递的特点是单向传递，即主调函数调用时给形参分配存储单元，把实参的值传递给形参，在调用结束后，形参的存储单元被释放，而形参值的任何变化都不会影响到实参的值，实参的存储单元仍保留并维持数值不变。

来看下面一个调用示例：
#include <stdio.h>
/* 变量x、y为Swap函数的形式参数 */
void Swap(int x, int y)
{
    int tmp;
    tmp = x;
    x = y;
    y = tmp;
    printf("x = %d, y = %d\n", x, y);
}
int main(void)
{
    int a=10;
    int b=20;
     /*变量a、b为Swap函数的实际参数*/
    Swap(a, b);
    printf("a = %d, b = %d\n", a, b);
    return 0;
}
在上面这个示例代码中，实参将值传递给形参，形参值发生互换后的值不能回传给主调函数。因此，主调函数中的数值不变，代码的运行结果为：
x = 20, y = 10
a = 10, b = 20

对于上面这个示例，或许有人会有如下疑问：上面的示例中明确地把 a、b 分别代入了 x、y 中，并在函数 Swap() 里完成了两个变量值的交换，为什么 a、b 变量值还是没有交换。其结果仍然是“a=10，b=20”，而不是“a=20，b=10”呢？

其实，原因很简单。函数在调用时，隐含地把实参 a 的值赋值给了参数 x，而将实参 b 的值赋值给了参数 y，如下面的代码所示：
/*将a的值赋值给x（隐含动作）*/
int x = a;
/*将a的值赋值给y（隐含动作）*/
int y = b;
因此，之后在 Swap() 函数体内再也没有对 a、b 进行任何操作。而在 Swap() 函数体内交换的只是 x、y，并不是 a、b，当然，a、b 的值没有改变。整个 Swap() 函数调用是按照如下顺序执行的：
/*将a的值赋值给x（隐含动作）*/
int x = a;
/*将a的值赋值给y（隐含动作）*/
int y = b;
int tmp;
tmp = x;
x = y;
y = tmp;
printf("x = %d, y = %d\n", x, y);
由此可见，函数只是把 a、b 的值通过赋值传递给 x、y，在函数 Swap() 中操作的只是 x、y 的值，并不是 a、b 的值，这也就是所谓的参数的值传递。
地址传递
这种方式使用数组名或者指针作为函数参数，传递的是该数组的首地址或指针的值，而形参接收到的是地址，即指向实参的存储单元，形参和实参占用相同的存储单元，这种传递方式称为“参数的地址传递”。

地址传递的特点是形参并不存在存储空间，编译系统不为形参数组分配内存。数组名或指针就是一组连续空间的首地址。因此在数组名或指针作函数参数时所进行的传送只是地址传送，形参在取得该首地址之后，与实参共同拥有一段内存空间，形参的变化也就是实参的变化。

来看下面一个调用示例：
void Swap(int *px, int *py)
{
    int tmp;
    tmp = *px;
    *px = *py;
    *py = tmp;
    printf("*px = %d, *py = %d\n", *px, *py);
}
int main(void)
{
    int a=10;
    int b=20;
    Swap(&a, &b);
    printf("a = %d, b = %d\n", a, b);
    return 0;
}
在上面的示例代码中，函数 void Swap(int*px,int*py) 中的参数 px、py 都是指针类型，在 main 函数中使用语句“Swap(&a,&b)”进行调用，该调用语句将 a 的地址(&a)代入 px，b 的地址(&b)代入 py。很显然，这里的函数调用有两个隐含操作：将 &a 的值赋值给参数 px，将 &b 的值赋值给参数 py，如下面的代码所示：
px = &a;
py = &b;
注意，这里与值传递方式存在着很大的区别。在值传递方式中，传递的是变量 a、b 的内容（即在上面的值传递示例代码中，将 a、b 的内容传递给参数 x、y）；而这里的地址传递方式则是将变量 a、b 的地址值（&a、&b）传递给参数 px、py。因此，整个 Swap() 函数调用是按照如下顺序执行的：
/*将&a的值赋值给px（隐含动作）*/
px = &a; /* ← */
/*将&b的值赋值给py（隐含动作）*/
py = &b;
int tmp;
tmp = *px;
*px = *py;
*py = tmp;
printf("*px = %d, *py = %d\n", *px, *py);
这样，有了前两行的隐含赋值操作，指针变量 px、py 的值已经分别是变量 a、b 的地址值（&a、&b）。接下来，对“*px”“*py”的操作当然也就是对 a、b 变量本身的操作了。所以 Swap() 函数中的交换操作就是对 a、b 值进行交换，这就是所谓的地址传递，运行结果为：
*px = 20, *py = 10
a = 20, b = 10


