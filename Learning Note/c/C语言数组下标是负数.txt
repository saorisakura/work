C语言数组下标是负数
2012年04月12日 10:33:06 霖枫007 阅读数：5065
        编程时我们经常会遇到处理边界问题的情况，这时数组的下标可能是从负数开始的。通常的方法是将边界分离出来单独处理，但这样比较麻烦，程序读起来也比较费力。那么能不能直观的用负数作为下标呢？

    C语言中数组下标必须是从0开始的，但C语言中的指针操作给我们提供了解决负数下标问题的方法。看下面一个示例：

#include "stdafx.h"

#include <iostream.h>

int main(int argc, char *argv[]) {

   int a[10];

   int i, *p;

   for (i=0; i<10; i++) {

        a[i] = i + 10;

    }

   printf("Using a...\n");

   for (i=0; i<10; i++) {

       printf("%d ", a[i]);

    }

   printf("\n");

   printf("Using p...\n");

    p= a + 1;

   for (i=-1; i<9; i++) {

       printf("%d ", p[i]);

    }

   printf("\n");

   return 0;

}

    上例中把a+1的值（地址）赋给p后，p[-1]＝*(p+(-1))=*(a+1-1)=*(a+0)=a[0]。

    可见，通过指针，可以使用负数下标。但有两点要注意：

一、如果下标是从负数开始的，那么下标上界也要做相应的变动

二、如果数组是动态申请的，则撤销数组所占内存时要free(a)而不是free(p)，因为a才真正指向数组空间的首地址。

 

       在使用数组的时候，相信大多数人首先想到的是“数组是从0开始的，数组的下标必须大于或等于0”，但是在处理一些数值计算的问题的时候，很可能会遇到下标为负数的问题，比如，在做9/7浮点小波变换的时候会有：x（m） =  x(-m) ,m＜０，在这种情况下，当要循环迭代计算的时候，就需要判断m是否为负数，这个还是有点麻烦的。

 

       这个时候，如果我们知道m的最小值，比如-4的时候，就可以考虑直接让数组的下标为负数了，具体的操作是：为数组x分配空间的时候，为其多分配4个位置，然后声明一个指针指向x+4，然后让b(-i) = b(i) ，i属于[1,4]，这样就可以在用到x的地方用b替代之，而不用检查下标的值了。但是，在这么做的时候一定要注意不要越界。

 

       这种用法的根据是C语言对数组和下标操作符的定义，C语言的数组其实是指针，而下标运算符其实解释成了指针加上偏移量，只是偏移量的单位是该指针的类型。

 

        比如，int a[20][43]，a[4][7]等价于a+4*43+7，这就可以解释为什么上面的b[-3]为什么行得通了，b=x+4，则b[-3]等价于x+4-3，其实是数组x的第二个元素。