6数组
6.1 数组
6.2 数组之间的赋值
6.3 数组的长度
6.4 #define
6.5 数组的倒置
6.6 数组查找算法
6.7 数组添加或删除元素
6.8 冒泡排序算法
6.9 插入排序算法
6.10 选择排序算法
6.11 快速排序算法
6.12 二维数组
6.13 一维字符数组
6.14 二维字符数组
6.15 数组的存储
6.16 数组和指针的区别
6.17 C语言一维数组的定义
6.18 数组越界
6.19 初始化数组，C语言中数组的初始化
6.20 C语言字符串数组
6.21 C语言多维数组，以及多维数组中的二维数组

数组的定义，初始化和使用，C语言数组详解
 数组数组之间的赋值 
数组可以说是目前为止讲到的第一个真正意义上存储数据的结构。虽然前面学习的变量也能存储数据，但变量所能存储的数据很有限。不仅如此，数组和指针（后续会讲）是相辅相成的，学习数组可以为学习指针打下基础。

那么到底什么是数组呢？顾名思义数组就是很多数的组合！那么这些数有没有什么要求呢，是不是不管什么数组合在一起都是数组呢？同一数组中存储的数必须满足以下两个条件：
这些数的类型必须相同。
这些数在内存中必须是连续存储的。

换句话说，数组是在内存中连续存储的具有相同类型的一组数据的集合。
一维数组
一维数组的定义方式如下：
类型说明符 数组名[常量表达式];

例如：
int a[5];
它表示定义了一个整型数组，数组名为 a，定义的数组称为数组 a。数组名 a 除了表示该数组之外，还表示该数组的首地址（关于地址现在先不讨论，稍后讲指针的时候再说）。

此时数组 a 中有 5 个元素，每个元素都是 int 型变量，而且它们在内存中的地址是连续分配的。也就是说，int 型变量占 4 字节的内存空间，那么 5 个int型变量就占 20 字节的内存空间，而且它们的地址是连续分配的。

这里的元素就是变量的意思，数组中习惯上称为元素。

在定义数组时，需要指定数组中元素的个数。方括号中的常量表达式就是用来指定元素的个数。数组中元素的个数又称数组的长度。

数组中既然有多个元素，那么如何区分这些元素呢？方法是通过给每个元素进行编号。数组元素的编号又叫下标。

数组中的下标是从 0 开始的（而不是 1）。那么，如何通过下标表示每个数组元素的呢？通过“数组名[下标]”的方式。例如“int a[5];”表示定义了有 5 个元素的数组 a，这 5 个元素分别为 a[0]、a[1]、a[2]、a[3]、a[4]。其中 a[0]、a[1]、a[2]、a[3]、a[4] 分别表示这 5 个元素的变量名。

为什么下标是从 0 开始而不是从 1 开始呢？试想，如果从 1 开始，那么数组的第 5 个元素就是 a[5]，而定义数组时是 int a[5]，两个都是 a[5] 就容易产生混淆。而下标从 0 开始就不存在这个问题了！所以定义一个数组 a[n]，那么这个数组中元素最大的下标是 n–1；而元素 a[i] 表示数组 a 中第 i+1 个元素。

另外，方括号中的常量表达式可以是“数字常量表达式”，也可以是“符号常量表达式”。但不管是什么表达式，必须是常量，绝对不能是变量。通常情况下 C 语言不允许对数组的长度进行动态定义，换句话说，数组的大小不依赖程序运行过程中变量的值。非通常的情况为动态内存分配，此种情况下数组的长度就可以动态定义，这个稍后会讲。
一维数组初始化
一维数组的初始化可以使用以下方法实现:
1) 定义数组时给所有元素赋初值，这叫“完全初始化”。例如：
int a[5] = {1, 2, 3, 4, 5};
通过将数组元素的初值依次放在一对花括号中，如此初始化之后，a[0]=1；a[1]=2；a[2]=3；a[3]=4；a[4]=5，即从左到右依次赋给每个元素。需要注意的是，初始化时各元素间是用逗号隔开的，不是用分号。

2) 可以只给一部分元素赋值，这叫“不完全初始化”。例如：
int a[5] = {1, 2};
定义的数组 a 有 5 个元素，但花括号内只提供两个初值，这表示只给前面两个元素 a[0]、a[1] 初始化，而后面三个元素都没有被初始化。不完全初始化时，没有被初始化的元素自动为 0。

需要注意的是，“不完全初始化”和“完全不初始化”不一样。如果“完全不初始化”，即只定义“int a[5]；”而不初始化，那么各个元素的值就不是0了，所有元素都是垃圾值。

你也不能写成“int a[5]={}；”。如果大括号中什么都不写，那就是极其严重的语法错误。大括号中最少要写一个数。比如“int a[5]={0}；”，这时就是给数组“清零”，此时数组中每个元素都是零。此外，如果定义的数组的长度比花括号中所提供的初值的个数少，也是语法错误，如“a[2]={1，2，3，4，5}；”。

3) 如果定义数组时就给数组中所有元素赋初值，那么就可以不指定数组的长度，因为此时元素的个数已经确定了。编程时我们经常都会使用这种写法，因为方便，既不会出问题，也不用自己计算有几个元素，系统会自动分配空间。例如：
int a[5] = {1, 2, 3, 4, 5};
可以写成：
int a[] = {1, 2, 3, 4, 5};
第二种写法的花括号中有 5 个数，所以系统会自动定义数组 a 的长度为 5。但是要注意，只有在定义数组时就初始化才可以这样写。如果定义数组时不初始化，那么省略数组长度就是语法错误。比如：
int a[];
那么编译时就会提示错误，编译器会提示你没有指定数组的长度。

下面给大家写一个简单的程序：
# include <stdio.h>
int main(void)
{
    int a[5] = {1, 2, 3, 4, 5};
    int i;
    for (i=0; i<5; ++i)
    {
        printf("%d\n", a[i]);
    }
    return 0;
}
输出结果是：
1
2
3
4
5

a 表示数组的名字，[5] 表示这个数组有 5 个元素，并分别用 a[0]、a[1]、a[2]、a[3]、a[4] 表示。并分别把花括号内的 1、2、3、4、5 赋给变量 a[0]、a[1]、a[2]、a[3]、a[4]。再次强调，下标从 0 开始，即从 a[0] 开始，而不是 a[1]。

也可以用 scanf 手动从键盘对数组进行初始化：
# include <stdio.h>
int main(void)
{
    int a[5] = {0};  //数组清零初始化
    int i;
    printf("请输入5个数:");
    for (i=0; i<5; ++i)
    {
        scanf("%d", &a[i] );
    }
    for (i=0; i<5; ++i)
    {
        printf("%d\x20", a[i]);
    }
    printf("\n");
    return 0;
}
输出结果是：
请输入5个数:1 2 3 4 5
1 2 3 4 5

同使用 scanf 给字符数组输入字符串时有所不同，输入数字时必须用 for 循环进行输入。而输入字符串时无须用循环，直接用 scanf 就可以了。
一维数组元素的引用
数组必须先定义，然后使用。C 语言规定，只能逐个引用数组元素，而不能一次引用整个数组。前面讲过，数组元素的表示形式为：
数组名[下标]

下标可以是整型常量或整型表达式，比如：
a[0] = a[5] + a[7] - a[2 * 3]
千万要注意，定义数组时用到的“数组名[常量表达式]”和引用数组元素时用到的“数组名[下标]”是有区别的，定义数组时的常量表达式表示的是数组的长度，而引用数组元素时的下标表示的是元素的编号。比如：
# include <stdio.h>
int main(void)
{
    int a[5] = {1, 2, 3, 4, 5};  //定义长度为5的数组a
    int t;
    t = a[3];  /*引用数组a中下标为3的元素a[3], 此时的3不代表数组的长度*/
    printf("t = %d\n", t);
    return 0;
}   
输出结果是：
t = 4

“int a[5]；”是定义了有 5 个元素的数组，这 5 个元素分别为 a[0]、a[1]、a[2]、a[3]、a[4]。而 t=a[3] 中的 a[3] 不是数组，只是其中的元素 a[3]。

因此，下面这个程序是错的：
# include <stdio.h>
int main(void)
{
    int a[5];
    a[5] = {1, 2, 3, 4, 5};
    return 0;
}
错误的原因是下面的 a[5] 不是数组。只有在定义的时候“a[常量]”表示的才是数组，此时方括号中的数字才表示数组长度。除此之外程序中任何地方看到“a[常量]”都不是数组，都只是数组的一个元素、一个变量，此时的“常量”表示的是元素的下标。

此外，当给元素单独赋值时不能加大括号，因为元素就是变量，即 a[5] 只是一个变量名。前面是怎么给变量赋值的现在就怎么给数组元素赋值，比如“a[5]=1；”。但是对于上面这个程序，这么写还是错误的。因为数组元素的下标是从 0 开始的，数组 a 的元素只有 a[0]~a[4]，并没有 a[5] 这个元素。


数组之间的赋值，C语言数组之间赋值详解

若定义了一个数组“int a[5]={1，2，3，4，5}；”，又定义了一个数组“int b[5]；”，那么如何编写程序才能将数组 a 中的数据赋给数组 b？

经常有人会这样写：
b = a;
这样写是错误的。前面说过，a 和 b 是数组名，而数组名表示的是数组“第一个元素”的“起始地址”。即 a 和 b 表示的是地址，是一个常数，不能将一个常数赋给另一个常数。这种错误就类似于将 3 赋给 2，所以是错误的（关于地址现在先不讨论，等后面讲指针的时候再说）。

正确的写法是用 for 循环，将数组 a 中的元素一个一个赋给数组b的元素：
# include <stdio.h>
int main(void)
{
    int a[5] = {1, 2, 3, 4, 5};
    int b[5];
    int i;
    for (i=0; i<5; ++i)
    {
        b[i] = a[i];
        printf("%d\n", b[i]);
    }
    return 0;
}
输出结果是：
1
2
3
4
5


数组的长度，C语言获取数组长度详解
 
如何通过编程的手段获取某个数组的长度呢？

答案是使用关键字 sizeof。

前面说过，用 sizeof 可以获得数据类型或变量在内存中所占的字节数。同样，用 sizeof 也可以获得整个数组在内存中所占的字节数。因为数组中每个元素的类型都是一样的，在内存中所占的字节数都是相同的，所以总的字节数除以一个元素所占的字节数就是数组的长度。

那么如何用 sizeof 获得数组总的字节数呢？只要对数组名使用 sizeof，求出的就是该数组总的字节数。下面写一个程序看一下：
# include <stdio.h>
int main(void)
{   
    int a[10] = {0};
    printf("sizeof(a) = %d\n", sizeof(a));
    return 0;
}
输出结果是：
sizeof(a) = 40

数组 a 是 int 型的，每个元素占 4 字节，所以长度为 10 的数组在内存中所占的字节数就是 40。而总的字节数除以一个元素所占的字节数就是数组的长度，如下面这个程序：
# include <stdio.h>
int main(void)
{   
    int a[10] = {0};
    int cnt = sizeof(a) / sizeof(a[0]);
    printf("cnt = %d\n", cnt);
    return 0;
}
输出结果是：
cnt = 10

这样不管数组是增加还是减少元素，sizeof(a)/sizeof(a[0]) 都能自动求出数组的长度。需要注意的是，它求出的是数组的总长度，而不是数组中存放的有意义的数据的个数。比如定义一个int型的数组：
int a[10] = {1, 2, 3, 4, 5};
我们只初始化了五个元素，但是 sizeof(a)/sizeof(a[0]) 求出的是 10，而不是 5。换句话说，我们无法通过 sizeof(a)/sizeof(a[0]) 求出数组中有多少个有意义的数据。


本节介绍将数组倒置的实现方法。所谓倒置就是将数组元素中的数据倒过来。
# include <stdio.h>
int main(void)
{
    int a[5] = {1, 2, 3, 4, 5};
    int b[5];  //用来存放倒置后的数据
    int i, j;
    for (i=0, j=4; i<5, j>=0; ++i, --j)
    {
        b[i] = a[j];
        printf("%d\n", b[i]);
    }
    return 0;
}
输出结果是：
5
4
3
2
1

此程序中，for 循环括号中的写法是正确的。前面讲过，for 循环的格式为：
for (表达式1；表达式2；表达式3)

这只是一般的形式。以表达式 1 为例，它是一个“整体”，它可以是一个表达式，也可以是多个表达式，如果是多个表达式就用逗号隔开，如程序中那样。但是如果表达式间用分号隔开就不能看成一个“整体”，即只能看成一个表达式了，如上面的“表达式 1；表达式 2；表达式 3”。

但是上面这个程序还不能称得上完美。程序中，完成相同功能执行的步数越少，算法就越好，效率也就越高。上面这个算法是完全的“复制”，数组有几个元素就执行多少次。其实有更好的算法，只需要上面算法执行步数的一半就能完成任务，即互换思想。

要完成倒置的功能，只需要第一个元素和最后一个元素交换、第二个元素和倒数第二个元素交换、第三个元素和倒数第三个元素交换……不管数组元素的个数是奇数还是偶数，这个算法都是成立的。如果是偶数那么每个元素都有机会交换；如果是奇数，那么最中间的那个元素就不交换。下面将数组加长，再将这种算法的程序给大家写一下：
# include <stdio.h>
int main(void)
{
    int a[23] = {1,5,66,8,55,9,1,32,5,65,4,8,5,15,64,156,1564,15,1,8,9,7,215};
    int i = 0;  //循环变量1, i的值为数组第一个元素的下标
    int j = 22;  //循环变量2, j的值为数组最后一个元素的下标
    int buf;  //互换时的中间存储变量
    for (; i<j; ++i, --j)  /*因为i和j已经初始化过了, 所以表达式1可以省略, 但表达式1后面的分号不能省。*/
    {
        buf = a[i];
        a[i] = a[j];
        a[j] = buf;
    }
    for (i=0; i<23; ++i)
    {
        printf("%d\x20", a[i]);  //\x20表示空格
    }
    printf("\n");
    return 0;
}
输出结果是：
215 7 9 8 1 15 1564 156 64 15 5 8 4 65 5 32 1 9 55 8 66 5 1


顺序查找算法和折半（二分法）查找算法，C语言查找算法详解

查找是指在大量的信息中寻找一个特定的信息。在计算机中，查找是非常重要的一个应用，比如“百度”。查找算法的好坏直接影响查找的速度。

常用的查找算法主要有顺序查找和折半（二分法）查找：
顺序查找是指从数组的一端开始逐个进行比较，直到找到该数据为止。
折半查找是指在已经排好序的一组数据中快速查找数据。

现实编程中，数据一般都是有序的。即使刚开始是无序的，但存储到数据库中时都是先将它们排好序然后再放进去，这样在实际应用中才能更方便。
顺序查找
查找数组 a 中第一次出现数字 m 的下标并输出该下标，如果没有则输出“sorry”，实现代码如下：
# include <stdio.h>
int main(void)
{
    int a[] = {1,5,66,8,55,9,1,32,5,65,4,8,5,15,64,156,1564,15,1,8,9,7,215,
           16,45,5,6,164,15,236,2,5,55,6,4,1,59,23,4,5,314,56,15,3,54,
           1,54,54,2,4,4,5,15,698,486,56,26,98,78,456,1894,564,26,56,5};
    int n;  //存放数组a中元素的个数
    int m;  //查找的数字
    int i;  //循环变量
    n = sizeof(a) / sizeof(int);  //求出数组中所有元素的个数
    printf("请输入一个数字:");
    scanf("%d", &m);
    for (i=0; i<n; ++i)
    {
        if (a[i] == m)
        {
            printf("下标 = %d\n", i);
            break;
        }
    }
    if (i == n)
    {
        printf("sorry\n");
    }
    return 0;
}
输出结果是：
请输入一个数字:7
下标 = 21
请输入一个数字:58
sorry
折半查找
折半查找是很有意思的，它的算法复杂度非常低，但它要求数据必须是已经排好序的。比如数组 a 中：
13  45  78  90  127  189  243  355

现在看看怎么用折半算法在其中查找 243。
1) 先定义一个变量 key 用于存放要查找的 243：
key = 243

2) 定义变量 low、mid和high 分别存储数组的最小下标、中间下标和最大下标。并有：
mid = (low+high)/2 = (0+7)/2 = 3

3) 此时 a[3]=90，而 key>90，说明 243 在 90 的右边，则往后查找：
low = mid + 1 = 4

4) 然后重新更新 mid：
mid = (4+7)/2 = 5

5) 此时 a[5]=189，而 key>189，说明 243 在 189 的右边，继续往后查找：
low = mid+1 = 6

6) 然后重新更新 mid：
mid = (6+7)/2 = 6

7) 此时 a[6]=key=243，找到了。

下面再来怎么查找 78：
1) key=78，mid=(low+high)/2=(0+7)/2=3。

2) 此时 a[3]=90，而 key<90，说明 78 在 90 的左边，则往前查找：
high = mid-1 = 2

3) 然后重新更新 mid：
mid = (0+2)/2 = 1

4) 此时 a[1]=45，而 key>45，说明 78 在 45 的右边，则往后查找：
low = 1+1 = 2

5) 然后重新更新 mid：
mid = (2+2)/2 = 2

6) 此时 a[2]=key=78，就找到了。

若所查找的在数据序列中没有呢？比如查找 123：
1) key=123，mid=(low+high)/2=(0+7)/2=3。

2) 此时 a[3]=90，而 key>90，说明 123 在 90 的左边，则往后查找：
low = mid+1 = 4

3) 然后重新更新 mid：
mid = (4+7)/2 = 5

4) 此时 a[5]=189，而 key<189，说明 123 在 189 的左边，则往前查找：
high=mid-1=4。

5) 此时 low==high，如果该数仍不是要找的数的话，说明该序列中就没有该数了。

下面将这个程序写下来：
# include <stdio.h>
int main(void)
{
    int a[] = {13, 45, 78, 90, 127, 189, 243, 355};
    int key;  //存放要查找的数
    int low = 0;
    int high = sizeof(a)/sizeof(a[0]) - 1;
    int mid;
    int flag = 0;  //标志位, 用于判断是否存在要找的数
    printf("请输入您想查找的数:");
    scanf("%d", &key);
    while ((low <= high))
    {
        mid = (low + high) / 2;
        if (key < a[mid])
        {
            high = mid - 1;
        }
        else if (a[mid] < key)
        {
            low = mid +1;
        }
        else
        {
            printf("下标 = %d\n", mid);
            flag = 1;
            break;
        }
    }
    if (0 == flag)
    {
        printf("sorry, data is not found\n");
    }
    return 0;
}
输出结果是：
请输入您想查找的数:78
下标 = 2
请输入您想查找的数:123
sorry, data is not found

折半查找在每次查找时都排除了一半数据，所以它的效率是非常高的。顺序查找的平均查找长度为 n+1/2，而折半查找的平均查找长度为 log2(n+1)-1。可见使用折半查找时，数据数量越多查找效率就越高。

但是，折半查找只适合数组，不适合链表。链表中也可以用折半查找，但是不仅不会提高效率，反而还会降低效率。因为数组可以通过下标直接找到 low、mid 和 high 对应的元素，而链表是通过指针连接起来的不连续的链，所以若要查找 low、mid 和 high 对应的元素，每次都要从第一个结点出发一个一个往后找。所以一般不在链表内使用折半查找。


二维数组的定义、初始化和输出，C语言二维数组详解

本节学习二维数组。二维数组与一维数组相似，但是用法上要比一维数组复杂一点。后面的编程中，二维数组用得很少，因为二维数组的本质就是一维数组，只不过形式上是二维的。能用二维数组解决的问题用一维数组也能解决。但是在某些情况下，比如矩阵，对于程序员来说使用二维数组会更形象直观，但对于计算机而言与一维数组是一样的。
二维数组的定义
二维数组定义的一般形式为：
类型说明符 数组名[ 常量表达式][ 常量表达式];

比如：
int a[3][4];
表示定义了一个 3×4，即 3 行 4 列总共有 12 个元素的数组 a。这 12 个元素的名字依次是：a[0][0]、a[0][1]、a[0][2]、a[0][3]；a[1][0]、a[1][1]、a[1][2]、a[1][3]；a[2][0]、a[2][1]、a[2][2]、a[2][3]。

与一维数组一样，行序号和列序号的下标都是从 0 开始的。元素 a[i][j] 表示第 i+1 行、第 j+1 列的元素。数组 int a[m][n] 最大范围处的元素是 a[m–1][n–1]。所以在引用数组元素时应该注意，下标值应在定义的数组大小的范围内。

此外，与一维数组一样，定义数组时用到的“数组名[常量表达式][常量表达式]”和引用数组元素时用到的“数组名[下标][下标]”是有区别的。前者是定义一个数组，以及该数组的维数和各维的大小。而后者仅仅是元素的下标，像坐标一样，对应一个具体的元素。

C 语言对二维数组采用这样的定义方式，使得二维数组可被看作一种特殊的一维数组，即它的元素为一维数组。比如“int a[3][4]；”可以看作有三个元素，每个元素都为一个长度为 4 的一维数组。而且 a[0]、a[2]、a[3] 分别是这三个一维数组的数组名。下面来验证一下看看是不是这么回事儿：
# include <stdio.h>
int main(void)
{
    int a[3][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};
    printf("%d\n", sizeof(a[0]));
    return 0;
}
输出结果是：
16

可见 a[0] 确实是第一行一维数组的数组名，其他同理。

在 C 语言中，二维数组中元素排列的顺序是按行存放的，即在内存中先顺序存放第一行的元素，再存放第二行的元素，这样依次存放。
二维数组的初始化
可以用下面的方法对二维数组进行初始化。

1) 分行给二维数组赋初值，比如上面程序的赋值方法：
int a[3][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};
这种赋初值的方法比较直观，将第一个花括号内的数据赋给第一行的元素、第二个花括号内的数据赋给第二行的元素……即每行看作一个元素，按行赋初值。

2) 也可以将所有数据写在一个花括号内，按数组排列的顺序对各元素赋初值。比如：
int a[3][4] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};
效果与第 1 种是一样的。但第1种方法更好，一行对一行，界限清楚。第 2 种方法如果数据多，写成一大片，容易遗漏，也不易检查。

3) 也可以只对部分元素赋初值。比如：
int a[3][4] = {{1, 2}, {5}, {9}};
它的作用是对第一行的前两个元素赋值、第二行和第三行的第一个元素赋值。其余元素自动为 0。初始化后数组各元素为：


 
4) 如果在定义数组时就对全部元素赋初值，即完全初始化，则第一维的长度可以不指定，但第二维的长度不能省。比如：
int a[3][4] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};
等价于：
int a[][4] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};
系统会根据数据总数和第二维的长度算出第一维的长度。但这种省略的写法几乎不用，因为可读性差。

5) int a[3][4]={0}；

二维数组“清零”，里面每一个元素都是零。
二维数组如何输出
二维数组有行和列，那么如何输出里面的元素呢？在讲述一维数组的时候说过，“数组的元素只能一个一个输出”，二维数组也不例外。在一维数组中是用一个 for 循环进行输出，而二维数组元素的输出要使用两个 for 循环嵌套。
# include <stdio.h>
int main(void)
{
    int a[3][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};
    int i;  //行循环变量
    int j;  //列循环变量
    for (i=0; i<3; ++i)
    {
        for (j=0; j<4; ++j)
        {
            printf("%-2d\x20", a[i][j]);
        }
        printf("\n");
    }
    return 0;
}
输出结果是：
1  2  3  4
5  6  7  8
9  10 11 12

提示：“printf（"%-2d\x20"，a[i][j]）；”中的“%-2d”，其中“-”表示左对齐，如果不写“-”则默认表示右对齐；“2”表示这个元素输出时占两个空格的空间，所以连同后面的 \x20 则每个元素输出时都占三个空格的空间。


