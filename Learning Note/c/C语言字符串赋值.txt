C语言中字符串赋值处理方式

C语言中，字符串可以赋值给字符指针变量，或者将字符串用字符数组保存。因为c语言没有直接对字符串提供语法糖方面的支持。而且C标准库很多方法处理字符串是以空字符结尾为前提的，这个必须要记住。

char *p,a='5';
p=&a;                     //显然是正确的，
p="abcd";              //但为什么也可以这样赋值？？

答： 
双引号做了3件事： 
1.申请了空间(在常量区)，存放了字符串 
2. 在字符串尾加上了’/0’ 
3.返回地址

这里就是 返回的地址 赋值给了 p

二、

char *p = “hello”;表达式为什么可以，而把p换成数组，然后再赋值就不行了

解释：

字符串常量”hello”出现在一个表达式中时，”hello”表达式使用的值就是这些字符所存储的地址（在常量区），而不是这些字符本身。

所以，可以把字符串赋值给指向字符的指针p，而不能把字符串赋值给一个字符数组。

char a[10] = “hello”; //这样可以，这种情况是c语言初始化所支持的

如果写成char a[10]

然后 a = “hello” 这样就错误了。

同样是a数组，char a[10] = “hello”;这种是数组的初始化，和a[0] = ‘h’ a[1] = ‘e’…是一个道理

但是换成char a [10]

然后a = “hello”就不行了 “hello”赋值的值是一个地址，而a虽然也有地址，但是这与指针是不一样的，指针的值是地址，而数组的值虽然也是地址，但是却是一个常量，所以不能给常量赋值。

代码测试

#include <stdio.h> 

int main()

{

       char *p = "hello";

       printf("%s",p);

       char a[10];

       a = "hello";

       return 0;

}

error C2440: '=' : cannot convert from 'char [6]' to 'char [10]'

        There is no context in which this conversion is possible

看到这样的错误提示，你是否会想到把char a[10]改成char a[6]呢

试一下，

error C2106: ‘=’ : left operand must be l-value

运算符的左边应该是一个“左值”。所谓“左值”就是指在程序中占用内存空间、可以被修改的量,比如各种变量。

在使用指针的时候，指针可以自增，而数组名不能自增

编译器给数组分配了空间，数组a的地址就表示一个常量了，让常量自增这肯定是不行的。

继续扩展： 
在指针自增的时候，编译器会自动识别类型，比如指针是指向int型的，想获取下一个的地址时，指针直接p++就行了，不要多此一举的p+4了 
特别需要注意的是： 
在void指针使用的时候，不能使用指针运算，因为void型编译器不能识别类型的长度（即指针所指对象的体积），p++这样就是不合法的，即不能进行数学运算，也不能使用*取值操作，想使用必须转换为其它的类型


C语言：字符串赋值的方法

main() 
{ 
char s[30]; 
strcpy(s, "Good News!"); /*给数组赋字符串*/ 
. 
. 
. 
} 
上面程序在编译时, 遇到char s[30]这条语句时, 编译程序会在内存的某处留 
出连续30个字节的区域, 并将第一个字节的地址赋给s。当遇到strcpy( strcpy 为 
Turbo C2.0的函数)时, 首先在目标文件的某处建立一个"Good News!/0" 的字符串。 
其中/0表示字符串终止, 终止符是编译时自动加上的, 然后一个字符一个字符地复 
制到s所指的内存区域。因此定义字符串数组时, 其元素个数至少应该比字符串的 
长度多1。 
注意: 
1. 字符串数组不能用"="直接赋值, 即s="Good News!"是不合法的。所以应分 
清字符串数组和字符串指针的不同赋值方法。 
2. 对于长字符串, Turbo C2.0允许使用下述方法: 
例如: 
main() 
{ 
char s[100]; 
strcpy(s, "The writer would like to thank you for" 
"your interest in his book. He hopes you" 
"can get some helps from the book."); 
. 
. 
. 
}


指针数组赋值
　


例如: 
main() 
{ 
char *f[2]; 
int *a[2]; 
f[0]="thank you"; /*给字符型数组指针变量赋值*/ 
f[1]="Good Morning"; 
*a[0]=1, *a[1]=-11; /*给整型数数组指针变量赋值*/ 
. 
. 
. 
}

 

------------------------------------------------------------------------------------------------------------------

补充：

无论是静态，局部还是全局数组只有在定义时才能初始话，否则必须通过其它方法，比如循环操作实现。

任何
int a[3];
static int b[3];
a[3] = {1, 2, 3};
b[3] = {1, 2, 3};
没有在定义时初始化都是错误的！

-------------------------------------------------------------------------------------------------------------------

以下是转载： 
学了这么多年的C语言，突然发现连字符串赋值都出错，真的很伤心。

char a[10];
怎么给这个数组赋值呢？
1、定义的时候直接用字符串赋值
char a[10]="hello";
注意：不能先定义再给它赋值，如char a[10]; a[10]="hello";这样是错误的！
2、对数组中字符逐个赋值
char a[10]={'h','e','l','l','o'};
3、利用strcpy
char a[10]; strcpy(a, "hello");

易错情况：
1、char a[10]; a[10]="hello";//一个字符怎么能容纳一个字符串？况且a[10]也是不存在的！
2、char a[10]; a="hello";//这种情况容易出现，a虽然是指针，但是它已经指向在堆栈中分配的10个字符空间，现在这个情况a又指向数据区中的hello常量，这里的指针a出现混乱，不允许！

还有：不能使用关系运算符“＝＝”来比较两个字符串，只能用strcmp() 函数来处理。


C语言的运算符根本无法操作字符串。在C语言中把字符串当作数组来处理，因此，对字符串的限制方式和对数组的一样，特别是，它们都不能用C语言的运算符进行复制和比较操作。


直接尝试对字符串进行复制或比较操作会失败。例如，假定str1和str2有如下声明：

char str1[10], str2[10];

利用=运算符来把字符串复制到字符数组中是不可能的：

str1 = "abc";     /*** WRONG ***/

str2 = str1;       /*** WRONG ***/

C语言把这些语句解释为一个指针与另一个指针之间的（非法的）赋值运算。但是，使用=初始化字符数组是合法的：

char str1[10] = "abc";

这是因为在声明中，=不是赋值运算符。

试图使用关系运算符或判等运算符来比较字符串是合法的，但不会产生预期的结果：

if (str1==str2) ...    /*** WRONG ***/

这条语句把str1和str2作为指针来进行比较，而不是比较两个数组的内容。因为str1和str2有不同的地址，所以表达式str1 == str2的值一定为0。

 

 

-------------------------------------------------------------------------------------------------------------------------------------

有空再查下动态数组的定义使用：

数组到底应该有多大才合适，有时可能不得而知。所以希望能够在运行时具有改变数组大小的能力。
动态数组就可以在任何时候改变大小。

 

通俗的说静态数组就是在定义数组的时候，由操作系统分配的空间，比如
int a[10];
这就是在定义时由系统给你分配了10个int类型的空间，这个空间是可以初始化的，比如
int a[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}；
那么在这个定义之后，系统会首先分配10个int类型的存储空间，然后把大括号里面的数字分别的，按顺序放到这10个空间里。你所做的只是写这么一句，而数组赋值的操作就由系统完成了。当然，初始化与否看你的需求，初始化不是强制性操作，想初始化就初始化，不想也没问题，还是上面的例子继续：
int a[10];
这里定义了，但是没初始化，这没有任何问题，以后你可以自己往里面赋值，比如
a[1] = 8;
a[5] = 3;
或者
for(int i = 0; i < 10; i++)
    a[i] = i;
等等

对于动态数组，不能被初始化，因为动态数组在定义时只是个指针，比如
int *a;
这里变量a只是个指向int类型的指针，而不是数组。动态分配有10个int类型元素的数组，如下：
a = (int) malloc(10*sizeof(int));
很明显，指针a在定义的时候不能被初始化，比如这样写就是错误的：
int *a = {1,2,3,4,5,6,7,8,9,10}; /* 错误！ */
因为a是只有4个字节的指针，没有可用的存储空间给需要初始化的变量。

----------------------------------------------------------------------------------------------------------------------------------------------------

 


第三节　　初始化数组
1．数组的初始化

　　数组可以初始化，即在定义时，使它包含程序马上能使用的值。
　　例如，下面的代码定义了一个全局数组，并用一组Fibonacci数初始化：
　　　　int iArray[10]={1，1，2，3，5，8，13，21，34，55)； //初始化
　　　　void main()
　　　　{
　　　　　　//...
　　　　}
　　初始化数组的值的个数不能多于数组元素个数，初始化数组的值也不能通过跳过逗号的方式来省略，这在C中是允许的，但在C++中不允许。
　　例如，下面的代码对数组进行初始化是错误的：
　　　　int arrayl[5]={1，2，3，4，5，6}; //error： 初始化值个数多于数组元素个数
　　　　int array2[5]={1，，2，3，4}； //error：初始化值不能省略
　　　　int array3[5]={1，2，3，}; //error：初始化值不能省略
　　　　int array4[5]={}; //error：语法格式错误
　　　　void main()
　　　　{
　　　　　　//...
　　　　}
　　初始化值的个数可少于数组元素个数。当初始化值的个数少于数组元素个数时，前面的按序初始化相应值， 后面的初始化为0(全局或静态数组)或为不确定值(局部数组)。
　　例如，下面的程序对数组进行初始化：
　　　　//*********************
　　　　//** 　　ch7_2.cpp　 **
　　　　//*********************

　　　　#include <iostream.h>

　　　　int array1[5]={1,2,3};
　　　　static int array2[5]={1};

　　　　void main()
　　　　{
　　　　　int arr1[5]={2};
　　　　　static int arr2[5]={1,2};

　　　　　int n;
　　　　　cout <<"global:/n";
　　　　　for(n=0; n<5; n++)
　　　　　　　cout <<" " <<array1[n];

　　　　　cout <<"/nglobal static:/n";
　　　　　for(n=0; n<5; n++)
　　　　　　　cout <<" " <<array2[n];

　　　　　cout <<"/nlocal:/n";
　　　　　for(n=0; n<5; n++)
　　　　　　　cout <<" " <<arr1[n];

　　　　　cout <<"/nlocal static:/n";
　　　　　for(n=0; n<5; n++)
　　　　　　　　cout <<" " <<arr2[n];
　　　　　cout <<endl;
　　　　}

　　运行结果为：
　　　　global：
　　　　　l　 2　 3 　0 　0
　　　　global static：

　　　　　1　 0　 0　 0　 0
　　　　local：
　　　　　2 23567 23567 23567 23567
　　　　local static：
　　　　　1　 2　 0　 0 　0
　　例中，全局数组和全局静态数组的初始化是在主函数运行之前完成的，而局部数组和局部静态数组的初始化是在进入主函数后完成的。
　　全局数组arrayl[5]对于初始化表的值按序初始化为1，2，3，还有两个元素的值则按默认初始化为0。
　　全局静态数组array2[5]与全局数组的初始化情况一样，初始化表值(1)表示第1个元素的值，而不是指全部数组元素都为1。
　　局部数组arrl[5]根据初始化表值的内容按序初始化， 由于初始化表值只有1个，所以还有4个元素的值为不确定。在这里均为数值23567。
　　局部静态数组arr2[5]先根据初始化表按序初始化，其余3个数组元素的值默认初始化为0。

2．初始化字符数组

　　初始化字符数组有两种方法，一种是：
　　　　char array[10]={"hello"}；
　　另一种是：
　　　　char array[10]={'h','e','l','l','/0'}；
　　第一种方法用途较广，初始化时，系统自动在数组没有填值的位置用，'/0'补上。另外， 这种方法中的花括号可以省略，即能表示成：
　　　　char array[10]="hello"；
　　第二种方法一次一个元素地初始化数组，如同初始化整型数组。这种方法通常用于输入不容易在键盘上生成的那些不可见字符。
　　例如，下面的代码中初始化值为若干制表符：
　　　　char chArray[5]={'/t','/t','/t','/t','/0')；
　　这里不要忘记为最后的，'/0'分配空间。如果要初始化一个字符串"hello"，那为它定义的数组至少有6个数组元素。
　　例如，下面的代码给数组初始化，但会引起不可预料的错误：
　　　　char array[5]="hello"；
　　该代码不会引起编译错误，但由于改写了数组空间以外的内存单元，所以是危险的。

3．省略数组大小

　　有初始化的数组定义可以省略方括号中的数组大小。
　　例如，下面的代码中数组定义为5个元素：
　　　　int a[]={2，4，6，8，10}；
　　编译时必须知道数组的大小。通常，声明数组时方括号内的数字决定了数组的大小。有初始化的数组定义又省略方括号中的数组大小时，编译器统计花括号之间的元素个数，以求出数组的大小。
　　例如，下面的代码产生相同的结果：
　　　　static int a1[5]={1，2，3，4，5};
　　　　static int a2[]={1，2，3，4，5}；
　　让编译器得出初始化数组的大小有几个好处。它常常用于初始化一个元素个数在初始化中确定的数组，提供程序员修改元素个数的机会。
　　在没有规定数组大小的情况下，怎么知道数组的大小呢? sizeof操作解决了该问题。 例如，下面的代码用sizeof确定数组的大小：

　　　　//*********************
　　　　//** ch7_3.cpp **
　　　　//*********************

　　　　#include <iostream.h>

　　　　void main()
　　　　{
　　　　　static int a[]={1,2,4,8,16};
　　　　　for(int i=0; i<(sizeof(a)/sizeof(int)); i++)
　　　　　　cout <<a[i] <<" ";
　　　　　cout <<endl;
　　　　}

　　运行结果为：
　　　　1 2 4 8 16
　　sizeof操作使for循环自动调整次数。如果要从初始化a数组的集合中增删元素，只需重新编译即可，其他内容无须更动。
　　每个数组所占的存储量都可以用sizeof操作来确定! sizeof返回指定项的字节数。sizeof常用于数组，使代码可在16位机器和32位机器之间移植：
　　对于字符串的初始化，要注意数组实际分配的空间大小是字符串中字符个数加上末尾的，'/0'，结束符。
　　例如，下面的代码定义一个字符数组：

　　　　//*********************
　　　　//**　　 ch7_4.cpp 　**
　　　　//*********************

　　　　#include <iostream.h>

　　　　void main()
　　　　{
　　　　　char ch[]="how are you";

　　　　　cout <<"size of array: " <<sizeof(ch) <<endl;
　　　　　cout <<"size of string: " <<strlen("how are you") 　　 　 　 　 　 <<endl;
　　　　}

　　运行结果为：
　　　　size of array：12
　　　　size of string：ll
　　例中，数组大小为12，而字符串长度为11。
　　省略数组大小只能在有初始化的数组定义中。
　　例如，下面的代码将产生一个编译错误：
　　　　int a[]；//error：没有确定数组大小
　　在定义数组的场合，无论如何，编译器必须知道数组的大小。
