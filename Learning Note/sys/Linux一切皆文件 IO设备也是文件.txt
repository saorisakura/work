Linux一切皆文件：I/O设备也是文件

Linux一切皆文件：I/O设备也是文件
输入/输出（I/O）是在主存和外部设备（如磁盘驱动器、终端和网络）之间复制数据的过程。输入操作是从I/O设备复制数据到主存，输出操作是从主存复制数据到I/O设备。

所有语言的运行时系统都提供执行I/O的较高级工具。如C提供printf和scanf这样执行带缓冲区的I/O函数，C++的重载操作符 <<（输入）和 >>（输出）提供类似功能。在Linux系统中，是通过使用由内核提供的系统级I/O函数来实现这些较高级别的I/O函数。

Linux一切皆文件：I/O设备也是文件
一个Linux文件就是一个m个字节的序列：

B0，B1，B2，...，Bm-1

所有的I/O设备（如网络、磁盘和终端）都被模型化文件，而所有的输入和输出都被当成对相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，成为Unix I/O，这使得所有的输入和输出都能以一种统一且一致的方式来执行。

Linux一切皆文件：I/O设备也是文件
Unix I/O模型是在操作系统内核中实现的，应用程序可以通过诸如open、close、lseek、read、write和stat这样的函数来访问Unix I/O。较高级别的RIO和标准I/O函数都是基于Unix I/O函数来实现的。

打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备。内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息，应用程序只需记住这个描述符。
Linux创建的每个进程开始时都有三个打开的文件：标准输入（描述符为0）、标准输出（描述符为1）和标准错误（描述符为2）。头文件<unistd.h>定义了常量STDIN_FILENO、STDOUT_FILENO和STDERR_FILENO，它们可用来代替显示的描述符值。
改变当前的文件位置。对于每个打开的文件，内核保持着一个文件位置k，初始为0。这个文件位置是从文件开头起始的字节偏移量。应用程序能够通过执行seek操作，显示地设置文件的当前位置为k。
读写文件。一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n。当k>=m时执行读操作会触发一个称为end-of-file（EOF）的条件，应用程序能够检测到这个条件。类似的，写操作就是从内存复制n>0个字节到一个文件，从当前文件位置k开始，然后更新k。
关闭文件。当应用完成了对文件的访问之后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。