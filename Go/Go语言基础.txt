Go语言fmt包详解
格式化输出函数

func Print(a ...interface{}) (n int, err error)
Print采用默认格式将其参数格式化并写入标准输出。如果两个相邻的参数都不是字符串，会在它们的输出之间添加空格，返回写入的字节数和遇到的任何错误。

func Printf(format string, a ...interface{}) (n int, err error)
Printf根据format参数生成格式化的字符串并写入标准输出，返回写入的字节数和遇到的任何错误。

func Println(a ...interface{}) (n int, err error)
Println采用默认格式将其参数格式化并写入标准输出。总是会在相邻参数的输出之间添加空格并在输出结束后添加换行符，返回写入的字节数和遇到的任何错误。

常用的格式化

Go语言的标准输出流在打印到屏幕时有些参数跟别的语言（比如C#和Java）不同，下面是我整理的一些常用的格式化操作。

普通占位符

占位符	说明	举例
%v	以默认的方式打印变量的值	fmt.Printf("%v", site)
%+v	在打印结构体时，会添加字段名	fmt.Printf("%+v", site)
%#v	在打印结构体时，会添加字段名和包名	fmt.Printf("%#v", site)
%T	打印变量的类型	fmt.Printf("%T", site)
%%	字面上的百分号，并非值的占位符	fmt.Printf("%%")
布尔占位符

占位符	说明	举例
%t	打印true或false	fmt.Printf("%t", true)
整数占位符

占位符	说明	举例
%b	表示为二进制	fmt.Printf("%b", 100)
%c	该值对应的unicode码值	fmt.Printf("%c", 0x4E2D)
%d	表示为十进制	fmt.Printf("%d", 0x12)
%o	表示为八进制	fmt.Printf("%d", 10)
%q	该值对应的单引号括起来的go语法字符字面值，必要时会采用安全的转义表示	fmt.Printf("%q", 0x4E2D)
%x	十六进制表示，字母形式为小写 a-f	fmt.Printf("%x", 13)
%X	十六进制表示，字母形式为大写 A-F	fmt.Printf("%x", 13)
%U	表示为Unicode格式：U+1234，等价于"U+%04X"	fmt.Printf("%U", 0x4E2D)
浮点数和复数的组成部分（实部和虚部）

占位符	说明	举例
%e	(=%.6e) 6位小数点
科学计数法，例如 -1234.456e+78	fmt.Printf("%e", 10.2)
%E	科学计数法，例如 -1234.456E+78	fmt.Printf("%e", 10.2)
%f	(=%.6f) 6位小数点
有小数点而无指数，例如 123.456	fmt.Printf("%f", 10.2)
%g	根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出	fmt.Printf("%g", 10.20)
%G	根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出	fmt.Printf("%G", 10.20+2i)
字符串与字节切片

占位符	说明	举例
%s	输出字符串表示（string类型或[]byte)	fmt.Printf("%s", []byte("oldboy"))
%10s	输出字符串最小宽度为10(右对齐)	fmt.Printf("%10s", "oldboy")
%-10s	输出字符串最小宽度为10(左对齐)	fmt.Printf("%-10s", "oldboy")
%.5s	输出字符串最大宽度为5	fmt.Printf("%.5s", "oldboy")
%5.10s	输出字符串最小宽度为5，最大宽度为10	fmt.Printf("%5.10s", "oldboy")
%-5.10s	输出字符串最小宽度为5，最大宽度为10(左对齐)	fmt.Printf("%-5.10s", "oldboy")
%5.3s	输出字符串宽度为5,如果原字符串宽度大于3,则截断	fmt.Printf("%5.3s", "oldboy")
%010s	如果宽度小于10，就会在字符串前面补零	fmt.Printf("%010s", "oldboy")
%q	双引号围绕的字符串，由Go语法安全地转义	fmt.Printf("%q", "oldboy")
%x	十六进制，小写字母，每字节两个字符	fmt.Printf("%x", "oldboy")
%X	十六进制，大写字母，每字节两个字符	fmt.Printf("%X", "oldboy")
指针

占位符	说明	举例
%p	十六进制表示，前缀 0x	fmt.Printf("%p", &site)
%#p	不带前缀 0x	fmt.Printf("%#p", &site)

Go语言string包详解
strings包实现了用于操作字符的简单函数。

查找操作

判断给定字符串s中是否包含子串substr, 找到返回true, 找不到返回false

func Contains(s, substr string) bool
实例如下：

package main

import (
    "fmt"
    "strings"
)

func main() {
    fmt.Println("包含子串返回：", strings.Contains("oldboy", "boy"))
    fmt.Println("不包含子串返回：", strings.Contains("oldboy", "girl"))
    fmt.Println("子字符串是空字符串返回：", strings.Contains("oldboy", ""))
    fmt.Println("原字符串、子字符串都是空字符串返回：", strings.Contains("", ""))
    fmt.Println("中文字符串包含子串返回：", strings.Contains("老男孩", "男孩"))
}
运行结果：

包含子串返回： true
不包含子串返回： false
子字符串是空字符串返回： true
原字符串、子字符串都是空字符串返回： true
中文字符串包含子串返回： true
在字符串s中查找sep所在的位置, 返回位置值, 找不到返回-1

func Index(s, sep string) int
实例如下：

package main

import (
    "fmt"
    "strings"
)

func main() {
    fmt.Println("存在返回第一个匹配字符的位置：", strings.Index("oldboy", "boy"))
    fmt.Println("不存在返回：", strings.Index("oldboy", "girl"))
    fmt.Println("中文字符串存在返回：", strings.Index("老男孩", "男孩"))
}
运行结果：

存在返回第一个匹配字符的位置： 3
不存在返回： -1
中文字符串存在返回： 3
统计给定子串sep的出现次数, sep为空时, 返回字符串的长度 + 1

func Count(s, sep string) int
实例如下：

package main

import (
    "fmt"
    "strings"
)

func main() {
    fmt.Println("子字符串出现次数：", strings.Count("oldboy", "o"))
    fmt.Println("子字符串为空时, 返回：", strings.Count("oldboy", ""))
}
运行结果：

子字符串出现次数： 2
子字符串为空时, 返回： 7
重复操作
重复s字符串count次, 最后返回新生成的重复的字符串

func Repeat(s string, count int) string
实例如下：

package main

import (
    "fmt"
    "strings"
)

func main() {
    fmt.Println(strings.Repeat("嘀嗒", 4), "时针它不停在转动")
}
运行结果：

嘀嗒嘀嗒嘀嗒嘀嗒 时针它不停在转动
替换操作
在s字符串中, 把old字符串替换为new字符串，n表示替换的次数，如果n<0会替换所有old子串。

func Replace(s, old, new string, n int) string
实例如下：

package main

import (
    "fmt"
    "strings"
)

func main() {
    fmt.Println(strings.Replace("luck luck luck", "k", "ky", 2))
    fmt.Println(strings.Replace("luck luck luck", "k", "ky", -1))
}

运行结果：

lucky lucky luck
lucky lucky lucky
删除操作
删除在s字符串的头部和尾部中由cutset指定的字符, 并返回删除后的字符串

func Trim(s string, cutset string) string
实例如下：

package main

import (
    "fmt"
    "strings"
)

func main() {
    fmt.Println(strings.Trim("   oldboy   ", " "))
}
运行结果：

oldboy
大小写转换
给定字符串转换为英文标题的首字母大写的格式(不能正确处理unicode标点)

func Title(s string) string
返回将所有字母都转为对应的小写版本的拷贝

func ToLower(s string) string
返回将所有字母都转为对应的大写版本的拷贝

func ToUpper(s string) string
实例如下：

package main

import (
    "fmt"
    "strings"
)

func main() {
    fmt.Println(strings.Title("It is never too late to learn."))
    fmt.Println(strings.ToLower("It Is Never Too Late To Learn."))
    fmt.Println(strings.ToUpper("It is never too late to learn."))
}
运行结果：

It Is Never Too Late To Learn.
it is never too late to learn.
IT IS NEVER TOO LATE TO LEARN.
字符串前缀后缀
判断字符串是否包含前缀prefix，大小写敏感

func HasPrefix(s, prefix string) bool
判断s是否有后缀字符串suffix，大小写敏感

func HasSuffix(s, suffix string) bool
实例如下：

package main

import (
    "fmt"
    "strings"
)

func main() {
    fmt.Println("前缀是以old开头的：", strings.HasPrefix("oldboy", "old"))
    fmt.Println("后缀是以boy开头的：", strings.HasSuffix("oldboy", "boy"))
}
运行结果：

前缀是以old开头的： true
后缀是以boy开头的： true
字符串分割
用去掉s中出现的sep的方式进行分割，会分割到结尾，并返回生成的所有片段组成的切片（每一个sep都会进行一次切割，即使两个sep相邻，也会进行两次切割）。如果sep为空字符，Split会将s切分成每一个unicode码值一个字符串。

func Split(s, sep string) []string
返回将字符串按照空白（unicode.IsSpace确定，可以是一到多个连续的空白字符）分割的多个字符串。如果字符串全部是空白或者是空字符串的话，会返回空切片。

func Fields(s string) []string
实例如下：

package main

import (
    "fmt"
    "strings"
)

func main() {
    fmt.Println("Split 函数的用法")
    fmt.Printf("%q\n", strings.Split("Linux,Python,Golang,Java", ","))
    fmt.Printf("%q\n", strings.Split("a mountain a temple", "a "))
    fmt.Printf("%q\n", strings.Split(" abc ", ""))
    fmt.Printf("%q\n", strings.Split("", "oldboy"))
    fmt.Println("Fields 函数的用法")
    fmt.Printf("Fields are: %q\n", strings.Fields(" Linux Python Golang  Java "))   --- 只识别空格
}
运行结果：

Split 函数的用法
["Linux" "Python" "Golang" "Java"]
["" "mountain " "temple"]
[" " "a" "b" "c" " "]
[""]
Fields 函数的用法
Fields are: ["Linux" "Python" "Golang" "Java"]


Go语言数组
数组是具有相同唯一类型的一组已编号且长度固定的数据项序列，这种类型可以是任意的原始类型例如整形、字符串或者自定义类型。

在Go语言中数组是固定长度的数据类型，它包含相同类型的连续的元素，这些元素可以是内建类型，像数字和字符串，也可以是结构类型，元素可以通过唯一的索引值访问，从0开始。

数组是很有价值的数据结构，因为它的内存分配是连续的，内存连续意味着可以让它在CPU缓存中待更久，所以迭代数组和移动元素都会非常迅速。

数组定义

第一种，通过指定数据类型和元素个数（数组长度）来声明数组。

声明一个长度为5的整数数组：

var array [5]int
声明一个长度为5的整数数组并初始化：

var array [5]int = [5]int{1, 2, 3, 4, 5}
第二种，一种快速创建和初始化数组的方法是使用数组字面值。数组字面值允许我们声明我们需要的元素个数并指定数据类型。

声明一个长度为5的字符串数组并初始化每个元素：

array := [5]string{"Linux", "Python", "Java", "Golang", "DBA"}
第三种，如果你把长度写成…，Go编译器将会根据你的元素来推导出长度。

通过初始化值的个数来推导出数组容量：

array := [...]int{1, 2, 3, 4, 5}
第四种，如果我们知道想要数组的长度，但是希望对指定位置元素初始化。

声明一个长度为5的整数数组，为索引为1和3的位置指定元素初始化，剩余元素为该元素类型的默认值：

array := [5]int{1: 1, 3: 3}
注意：当一个数组被声明时，它里面包含的每个元素都会被初始化为该元素类型的默认值。一旦数组被声明了，那么它的数据类型跟长度都不能再被改变。如果你需要更多的元素，那么只能创建一个你想要长度的新的数组，然后把原有数组的元素拷贝过去。

数组操作

使用内置函数len()和cap()返回数组长度和数组容量。实例如下：

package main

import "fmt"

func main() {
    array := [2]int{}
    fmt.Printf("数组长度：%d，数组容量：%d\n", len(array), cap(array))
}
运行结果：

数组长度：2，数组容量：2
使用 [] 操作符来访问数组元素：

改变索引为2的元素的值：

array := [5]int{1, 2, 3, 4, 5}
array[2] = 100
注意：数组可以通过下标进行访问，数组下标是从0开始，最后一个元素下标是：len(array)-1。如果下标在数组合法范围之外，则触发访问越界。实例如下：

package main

func main() {
    array := [5]int{1, 2, 3, 4, 5}
    array[5] = 100
}
编译错误：

./main.go:5:7: invalid array index 5 (out of bounds for 5-element array)
数组赋值操作，一个数组可以被赋值给任意相同类型的数组：

var arr1 [5]string
arr2 := [5]string{"Linux", "Python", "Java", "Golang", "DBA"}
arr1 = arr2
注意：

数组的类型同时包括数组的长度和可以被存储的元素类型，数组类型完全相同才可以互相赋值，实例如下：

package main

import "fmt"

func main() {
    var arr1 [3]string
    arr2 := [5]string{"Linux", "Python", "Java", "Golang", "DBA"}
    arr1 = arr2
    fmt.Println(arr1)
}
编译错误：

./main.go:8:7: cannot use arr2 (type [5]string) as type [3]string in assignment
多维数组

数组总是一维的，但是可以组合成多维的。多维数组通常用于有父子关系的数据或者是坐标系数据：

声明一个二维数组

var array [3][6]int
使用数组字面值声明并初始化

array := [4][2]int{{10, 11}, {20, 21}, {30, 31}, {40, 41}}
指定外部数组索引位置初始化

array := [4][2]int{1: {20, 21}, 3: {40, 41}}
同时指定内外部数组索引位置初始化

array := [4][2]int{1: {20, 21}, 3: {40, 41}}
使用内置函数len()和cap()返回多维数组长度和多维数组容量。实例如下：

package main

import "fmt"

func main() {
    array := [3][6]int{}
    fmt.Printf("数组长度：%d，数组容量：%d\n", len(array), cap(array))
}
运行结果：

数组长度：3，数组容量：3
通过 [] 操作符来访问数组元素：

var array [2][2]int
array[0][0] = 0
array[0][1] = 1
array[1][0] = 2
array[1][1] = 3
相同类型的多维数组相互赋值：

var arr1 [2][2]int
var arr2 [2][2]int
arr2[0][0] = 0
arr2[0][1] = 1
arr2[1][0] = 2
arr2[1][1] = 3
arr1 = arr2


Go语言类型转换
类型转换用于将一种数据类型的变量转换为另外一种类型的变量。

Go语言类型转换基本格式如下：
表达式 T(v) 将值 v 转换为类型 T 。

Go语言各种类型转换及函数的高级用法：
strconv包实现了基本数据类型和其字符串表示的相互转换。

转字节

字符串转字节

package main

import (
    "fmt"
    "reflect"
)

func main() {
    var str string = "oldboy"
    result := []byte(str)
    fmt.Printf("result is %v , result type is %v\n", result, reflect.TypeOf(result))
}
32位整形转字节

package main

import (
    "bytes"
    "encoding/binary"
    "fmt"
    "reflect"
)

func main() {
    var x int32
    x = 100
    bytesBuffer := bytes.NewBuffer([]byte{})
    binary.Write(bytesBuffer, binary.BigEndian, x)
    result := bytesBuffer.Bytes()
    fmt.Printf("result is %v , result type is %v\n", result, reflect.TypeOf(result))
}
转字符串

字节转字符串

package main

import (
    "fmt"
    "reflect"
)

func main() {
    var b []byte = []byte{111, 108, 100, 98, 111, 121}
    result := string(b)
    fmt.Printf("result is %v , result type is %v\n", result, reflect.TypeOf(result))
}
整形转字符串

package main

import (
    "fmt"
    "reflect"
    "strconv"
)

func main() {
    var x int
    x = 100
    result := strconv.Itoa(x)
    fmt.Printf("result is %v , result type is %v\n", result, reflect.TypeOf(result))
}
FormatInt 将 int 型整数 i 转换为字符串形式 
base：进位制（2 进制到 36 进制） 大于 10 进制的数，返回值使用小写字母 ‘a’ 到 ‘z’

func FormatInt(i int64, base int) string
Itoa 相当于 FormatInt(i, 10)

64位整形转字符串

package main

import (
    "fmt"
    "reflect"
    "strconv"
)

func main() {
    var i int64
    i = 0x100
    result := strconv.FormatInt(i, 10)
    fmt.Printf("result is %v , result type is %v\n", result, reflect.TypeOf(result))
}
布尔值转字符串

package main

import (
    "fmt"
    "reflect"
    "strconv"
)

func main() {
    t := strconv.FormatBool(true)
    f := strconv.FormatBool(false)
    fmt.Printf("t is %v , t type is %v\n", t, reflect.TypeOf(t))
    fmt.Printf("f is %v , f type is %v\n", f, reflect.TypeOf(f))
}
浮点数转字符串

strconv.FormatFloat(f,fmt,prec,bitSize)
f：要转换的浮点数 
fmt：格式标记（b、e、E、,f、g、G） 
prec：精度（数字部分的长度，不包括指数部分） 
bitSize：指定浮点类型（32:float32、64:float64）

格式标记： 
‘b’ (-ddddp±ddd，二进制指数) 
‘e’ (-d.dddde±dd，十进制指数) 
‘E’ (-d.ddddE±dd，十进制指数) 
‘f’ (-ddd.dddd，没有指数) 
‘g’ (‘e’:大指数，’f’:其它情况) 
‘G’ (‘E’:大指数，’f’:其它情况)
package main

import (
    "fmt"
    "reflect"
    "strconv"
)

func main() {
    f := 100.12345678901234567890123456789
    result := strconv.FormatFloat(f, 'e', 30, 32)
    fmt.Printf("result is %v , result type is %v\n", result, reflect.TypeOf(result))
}
转整形

int转int64

package main

import (
    "fmt"
    "reflect"
)

func main() {
    var x int = 100
    result := int64(x)
    fmt.Printf("result is %v , result type is %v\n", result, reflect.TypeOf(result))
}
字符串转整形

package main

import (
    "fmt"
    "reflect"
    "strconv"
)

func main() {
    var str string
    str = "100"
    result, _ := strconv.Atoi(str)
    fmt.Printf("result is %v , result type is %v\n", result, reflect.TypeOf(result))
}
字节转32位整形

package main

import (
    "bytes"
    "encoding/binary"
    "fmt"
    "reflect"
)

func main() {
    b := []byte{0x00, 0x00, 0x03, 0xe8}
    bytesBuffer := bytes.NewBuffer(b)

    var result int32
    binary.Read(bytesBuffer, binary.BigEndian, &result)
    fmt.Printf("result is %v , result type is %v\n", result, reflect.TypeOf(result))
}
转浮点型

float32转float64

package main

import (
    "fmt"
    "reflect"
)

func main() {
    var x float32 = 100
    result := float64(x)
    fmt.Printf("result is %v , result type is %v\n", result, reflect.TypeOf(result))
}
整型转浮点型

package main

import (
    "fmt"
    "reflect"
)

func main() {
    var x int = 100
    result := float32(x)
    fmt.Printf("result is %v , result type is %v\n", result, reflect.TypeOf(result))
}
字符串转浮点数

strconv.ParseFloat(str,bitSize)
str：要转换的字符串
bitSize：指定浮点类型（32:float32、64:float64）
如果 str 是合法的格式，而且接近一个浮点值，
则返回浮点数的四舍五入值（依据 IEEE754 的四舍五入标准）
如果 str 不是合法的格式，则返回“语法错误”
如果转换结果超出 bitSize 范围，则返回“超出范围”
package main

import (
    "fmt"
    "reflect"
    "strconv"
)

func main() {
    var str string = "0.12345678901234567890"
    result, _ := strconv.ParseFloat(str, 32)
    fmt.Printf("result is %v , result type is %v\n", result, reflect.TypeOf(result))
}
转布尔值

字符串转布尔值

ParseBool 将字符串转换为布尔值 
它接受真值：1, t, T, TRUE, true, True 
它接受假值：0, f, F, FALSE, false, False. 
其它任何值都返回一个错误
package main

import (
    "fmt"
    "reflect"
    "strconv"
)

func main() {
    result, _ := strconv.ParseBool("1")
    fmt.Printf("result is %v , result type is %v\n", result, reflect.TypeOf(result))
}
注意：Go语言不能将其他类型当 bool 值使用。

package main

func main() {
    a := 100
    if a {
    }
}
编译错误：

./main.go:5:2: non-bool a (type int) used as if condition


Go语言切片

Go语言切片是对数组的抽象。数组的长度不可改变，在特定场景中这样的集合就不太适用，Go中提供了一种灵活，功能强悍的内置类型切片（"动态数组"），与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。

需要说明，slice 并不是数组或数组指针。它通过内部指针和相关属性引用数组片段，以实现变长方案。

切片定义

第一种，声明一个切片：

var slice []int

切片定义并初始化

var slice0 []int = []int{1, 2, 3}
var slice1 = []int{1, 2, 3}

第二种，通过make来创建切片

var slice0 []int = make([]int, 10)
var slice1 = make([]int, 10)
var slice2 = make([]int, 10, 10)

第三种，通过 := 语法来定义切片

slice0 := []int{}
slice1 := make([]int, 10)
slice2 := make([]int, 10, 10)

第四种，通过操作数组来创建切片

var array = [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
var slice0 []int = array[2:8]

// 可以简写为 var slice []int = array[:end]
var slice1 []int = array[0:6]

// 可以简写为 var slice[]int = array[start:]
var slice2 []int = array[5:10]

// 可以简写为var slice []int = array[:]
var slice3 []int = array[0:len(array)]

// 去掉切片的最后一个元素
var slice4 = array[:len(array)-1]
第五种，通过两个冒号创建切片，slice[x:y:z]切片实体[x:y]，切片长度len = y-x，切片容量cap = z-x

package main

import (
    "fmt"
)

func main() {
    slice := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
    slice1 := slice[6:8]
    fmt.Printf("slice1 : %v , len : %d , cap : %d\n", slice1, len(slice1), cap(slice1))
    slice2 := slice[2:6:8]
    fmt.Printf("slice2 : %v , len : %d , cap : %d\n", slice2, len(slice2), cap(slice2))
}

slice1[6:8]，从第6位到第8位（返回[6 7]），长度len为2，最大可扩充长度cap为4

slice2[2:6:8]，从第2位到第6位（返回[2 3 4 5]），长度len为4，最大可扩充长度cap为6

切片操作

切片长度，可以由 len() 函数获取切片长度。
切片容量，可以由 cap() 函数获取切片最长可以达到多少。

package main

import "fmt"

func main() {
    // 通过初始化表达式构造，可使用索引号。
    s1 := []int{0, 1, 2, 3, 8: 100}
    fmt.Println(s1, len(s1), cap(s1))

    // 使用 make 创建，指定 len 和 cap 值。
    s2 := make([]int, 6, 8)
    fmt.Println(s2, len(s2), cap(s2))

    // 省略 cap，相当于 cap = len。
    s3 := make([]int, 6)
    fmt.Println(s3, len(s3), cap(s3))
}

如果 slice == nil，那么 len、cap 结果都等于 0。

  var ss []string;
  fmt.Printf("[ local print ]\t:\t length:%v\taddr:%p\tisnil:%v\n",len(ss),ss, ss==nil)  
  print("func print",ss)
  //切片尾部追加元素append elemnt
  for i:=0;i<10;i++{
    ss=append(ss,fmt.Sprintf("s%d",i));
  }
  fmt.Printf("[ local print ]\t:\tlength:%v\taddr:%p\tisnil:%v\n",len(ss),ss, ss==nil)  
  print("after append",ss)
  //删除切片元素remove element at index
  index:=5;
  ss=append(ss[:index],ss[index+1:]...)
  print("after delete",ss)
  //在切片中间插入元素insert element at index;
  //注意：保存后部剩余元素，必须新建一个临时切片
  rear:=append([]string{},ss[index:]...) 
  ss=append(ss[0:index],"inserted")
  ss=append(ss,rear...)
  print("after insert",ss)

切片追加，使用append() 函数向 slice 尾部添加数据，返回新的 slice

package main

import (
    "fmt"
)

func main() {

    var a = []int{1, 2, 3}

    // 一次 append 一个值
    b := append(a, 4)

    // 一次 append 多个值
    c := append(b, 5, 6, 7)

    // 一次 append 一个切片
    var d = []int{8, 9, 10}
    e := append(c, d...)

    fmt.Println(a, b, c, d, e)
}

切片拷贝，使用copy() 函数 copy 在两个 slice 间复制数据，复制长度以 len 小的为准。两个 slice 可指向同一底层数组，允许元素区间重叠。

package main

import (
    "fmt"
)

func main() {
    var a = []int{1, 2, 3, 4, 5}
    b := []int{100, 200}
    copy(a, b)
    fmt.Println(a, b)
}

运行结果：

[100 200 3 4 5] [100 200]

package main

import (
    "fmt"
)

func main() {
    var a = []int{1, 2, 3, 4, 5}
    b := []int{100, 200}
    copy(b, a)
    fmt.Println(a, b)
}

运行结果：

[1 2 3 4 5] [1 2]

slice中cap重新分配规律：

package main

import (
    "fmt"
)

func main() {

    s := make([]int, 0, 1)
    c := cap(s)

    for i := 0; i < 50; i++ {
        s = append(s, i)
        if n := cap(s); n > c {
            fmt.Printf("cap: %d -> %d\n", c, n)
            c = n
        }
    }

}
运行结果：

cap: 1 -> 2
cap: 2 -> 4
cap: 4 -> 8
cap: 8 -> 16
cap: 16 -> 32
cap: 32 -> 64


Go语言容器
Map 是一种无序的键值对的集合。Map 最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值。

Map 是一种集合，所以我们可以像迭代数组和切片那样迭代它。不过，Map 是无序的，我们无法决定它的返回顺序，这是因为 Map 是使用 hash 表来实现的。

键必须是支持相等运算符 ("=="、"!=") 类型， 如 number、string、 pointer、array、struct，以及对应的 interface。

值可以是任意类型，没有限制。

定义 Map

第一种，声明一个Map：

var m map[int]string
Map定义并初始化

var m1 map[int]string = map[int]string{0: "Linux", 1: "Python"}
var m2 = map[int]string{0: "Java", 1: "Golang"}
第二种，通过make来创建Map

var m1 map[int]string = make(map[int]string, 10)
var m2 = make(map[int]string, 10)
第三种，通过 := 语法来定义Map

m1 := map[int]string{}
m2 := make(map[int]string, 10)
Map操作

插入操作：

package main

import "fmt"

func main() {
    m := map[string]string{"key0": "Linux", "key1": "Python"}
    fmt.Printf("插入前：map m : %v\n", m)
    m["key2"] = "oldboy"
    fmt.Printf("插入后：map m : %v\n", m)
}
更新操作：

package main

import "fmt"

func main() {
    m := map[string]string{"key0": "Linux", "key1": "Python"}
    fmt.Printf("更新前：map m : %v\n", m)
    m["key1"] = "Golang"
    fmt.Printf("更新后：map m : %v\n", m)
}
查找操作：

package main

import "fmt"

func main() {
    m := map[string]string{"key0": "Linux", "key1": "Python"}
    val, ok := m["key0"]
    if ok {
        fmt.Printf("查找操作：key0 => %v\n", val)
    }
}
删除操作：

package main

import "fmt"

func main() {
    m := map[string]string{"key0": "Linux", "key1": "Python"}
    fmt.Printf("删除前：map m : %v\n", m)
    delete(m, "key1")
    fmt.Printf("删除后：map m : %v\n", m)
}
删除操作，如果 key 不存在，不会出错。

package main

import "fmt"

func main() {
    m := map[string]string{"key0": "Linux", "key1": "Python"}
    fmt.Printf("删除前：map m : %v\n", m)
    delete(m, "key10")
    fmt.Printf("删除后：map m : %v\n", m)
}
求长度：

package main

import "fmt"

func main() {
    m := map[string]string{"key0": "Linux", "key1": "Python"}
    len := len(m)
    fmt.Printf("map m 长度: %v\n", len)
}
注意：不可以在map上使用cap()方法。

package main

import "fmt"

func main() {
    m := map[string]string{"key0": "Linux", "key1": "Python"}
    cap := cap(m)
    fmt.Printf("map's cap is %v\n", cap)
}
编译错误：

./main.go:7:12: invalid argument m (type map[string]string) for cap


Go语言管道
Channel概念

Channel 是Go中的一个核心类型，你可以把它看成一个管道。Channel是引用类型，操作符是箭头 <- 。
Channel 是 CSP 模式的具体实现，用于多个 goroutine 通讯。其内部实现了同步，确保并发安全。
Channel 是线程安全的，先进先出，多个goroutine同时访问，不需要加锁，channel是有类型的，一个整数的channel只能存放整数。

Channel定义

第一种，channel声明

声明int类型的chan

var ch chan int
声明string类型的chan

var ch chan string
声明map类型chan

var ch chan map[int]string
第二种，使用make定义，无缓冲channel

var ch1 chan int = make(chan int)
var ch2 = make(chan int)
ch3 := make(chan int)
第三种，使用make定义，有缓冲channel

var ch1 chan int = make(chan int, 10)
var ch2 = make(chan int, 10)
ch3 := make(chan int, 10)
第四种，只读channel

var ch1 <-chan int
var ch2 <-chan int = make(<-chan int, 10)
var ch3 = make(<-chan int, 10)
ch4 := make(<-chan int, 10)
第五种，只写channel

var ch1 chan<- int
var ch2 chan<- int = make(chan<- int, 10)
var ch3 = make(chan<- int, 10)
ch4 := make(chan<- int, 10)
Channel特点

无缓冲的与有缓冲channel有着重大差别，那就是一个是同步的 一个是非同步的。

比如

无缓冲chan：ch1:=make(chan int)

有缓冲chan：ch2:=make(chan int,1)

无缓冲： ch1<-1 不仅仅是向 c1 通道放 1，而是一直要等有别的携程 <-ch1 接手了这个参数，那么ch1<-1才会继续下去，要不然就一直阻塞着。

有缓冲： ch2<-1 则不会阻塞，因为缓冲大小是1(其实是缓冲大小为0)，只有当放第二个值的时候，第一个还没被人拿走，这时候才会阻塞。

缓冲区是内部属性，并非类型构成要素。

普通 channel 可以隐式转为只读channel或只写channel。

package main

var ch = make(chan int, 3)
var send chan<- int = ch
var recv <-chan int = ch

func main() {

}
只读channel或只写channel不能转为普通 channel。

package main

func main() {
    var send chan<- int
    var recv <-chan int

    ch1 := (chan int)(send)
    ch2 := (chan int)(recv)
}
编译错误：

./main.go:7:19: cannot convert send (type chan<- int) to type chan int
./main.go:8:19: cannot convert recv (type <-chan int) to type chan int
Channel操作

使用内置函数 len() 返回未被读取的缓冲元素数量，使用内置函数 cap() 返回缓冲区大小。

package main

import "fmt"

func main() {
    ch1 := make(chan int)
    ch2 := make(chan int, 3)

    ch2 <- 1

    fmt.Printf("ch1 缓冲元素数量：%v,缓冲区大小：%v\n", len(ch1), cap(ch1))
    fmt.Printf("ch2 缓冲元素数量：%v,缓冲区大小：%v\n", len(ch2), cap(ch2))
}
运行结果：

ch1 缓冲元素数量：0,缓冲区大小：0
ch2 缓冲元素数量：1,缓冲区大小：3
channel 写入、读取操作：

package main

import "fmt"

func main() {
    ch := make(chan int, 1)
    // 写入chan
    ch <- 99

    // 读取chan
    value, ok := <-ch
    if ok {
        fmt.Printf("读取chan：%v\n", value)
    }

}
channel 关闭操作：

1、使用内置函数 close() 进行关闭 chan。
2、chan关闭之后，for range遍历chan中已经存在的元素后结束。
3、没有使用for range的写法需要使用，val, ok := <- ch进行判断chan是否关闭。

package main

import "fmt"

func main() {
    ch := make(chan int, 5)

    ch <- 1
    ch <- 2
    ch <- 3

    close(ch)
    for {
        val, ok := <-ch
        if ok == false {
            fmt.Println("chan is closed")
            break
        }
        fmt.Println(val)
    }
}
注意：向已经关闭的 channel 发送数据会引发 panic 错误。

package main

func main() {
    ch := make(chan int, 1)
    close(ch)
    ch <- 100
}
运行错误：

panic: send on closed channel


package main

import (
	"fmt"
	"strings"
	"reflect"
	"bytes"
	"encoding/binary"
)

type Books struct {
	name string
	author string
	id int
	datein string
	dateout string
}

func main() {
	b := Books{
		name: "prejudice",
		author: "liyang",
		id: 1,
		datein: "20180814",
		dateout: "none",
	}
	array := [5]string{"Linux", "Python", "Java", "Golang", "DBA"}
	data, err := fmt.Println("hahaha")
	fmt.Println(data, err)
	fmt.Print("adasd", "dasdasd\n")
	fmt.Printf("%v\n", b)
	fmt.Printf("%+v\n", b)
	fmt.Printf("%#v\n", b)

	fmt.Println("liyang string has li ---> ", strings.Contains("liyang", "li"))
	fmt.Printf("Fields are: %q\n", strings.Fields("Linux Python Java     Golang"))
	fmt.Println("Fields are: ", strings.Split("Linux,Python,Java,Golang", ","))
	fmt.Println(array)

	str := "liyang"
	bstr := []byte(str)
	fmt.Printf("str is %v, type is :%v\n", bstr, reflect.TypeOf(bstr))

	var x int32
	x = 100
	bytesBuffer := bytes.NewBuffer([]byte{})
	binary.Write(bytesBuffer, binary.BigEndian, x)
	result := bytesBuffer.Bytes()
	fmt.Printf("result is %v , result type is %v\n", result, reflect.TypeOf(result))

	slice0 := []int{}
	slice1 := make([]int, 10)
	slice2 := make([]int, 10, 10)
	fmt.Println(slice0, slice1, slice2)
}
运行结果：
hahaha
7 <nil>
adasddasdasd
{prejudice liyang 1 20180814 none}
{name:prejudice author:liyang id:1 datein:20180814 dateout:none}
main.Books{name:"prejudice", author:"liyang", id:1, datein:"20180814", dateout:"none"}
liyang string has li --->  true
Fields are: ["Linux" "Python" "Java" "Golang"]
Fields are:  [Linux Python Java Golang]
[Linux Python Java Golang DBA]
str is [108 105 121 97 110 103], type is :[]uint8
result is [0 0 0 100] , result type is []uint8
[] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0]


Go语言指针
指针（Pointer）是编程语言中的一个对象，利用地址，它的值直接指向（points to）存在电脑存储器中另一个地方的值。由于通过地址能找到所需的变量单元，可以说，地址指向该变量单元。因此，将地址形象化的称为“指针”。意思是通过它能找到以它为地址的内存单元。一个指针变量指向了一个值的内存地址。

Go语言支持指针类型*T，指针的指针**T，以及包含包名前缀的*package.T。

指针声明
在指针类型变量前面加上 *（取值符）来获取指针所指向的内容。
在值类型变量前面加上 &（取地址符）来获取该变量的指针。

声明一个int值的指针变量

var ip *int
声明一个string值的指针变量

var sp *string
通过 := 语法来定义指针

var str string = "oldboy"
sp := &str
声明一个int值的指针的指针变量

var p **int
声明一个time.Time值的指针变量

var t *time.Time
打印变量在内存中的地址：

package main

import "fmt"

func main() {
    var str string = "oldboy"

    fmt.Printf("变量的地址: %x\n", &str)
}
运行结果：

变量的地址: c42000e1d0
空指针

当一个指针被定义后没有分配到任何变量时，它的值为 nil。nil 指针也称为空指针。

nil在概念上和其它语言的null、None、nil、NULL一样，都指代零值或空值。

package main

import (
    "fmt"
)

func main() {
    var ip *int
    var sp *string

    if ip == nil {
        fmt.Println("ip == nil")
    }
    if sp == nil {
        fmt.Println("sp == nil")
    }
}
定义的不同类型的零值不能用于比较运算，实例如下：

package main

import (
    "fmt"
)

func main() {
    var ip *int
    var sp *string

    if ip == sp {
        fmt.Println("error")
    }
}
编译错误：

./main.go:11:8: invalid operation: ip == sp (mismatched types *int and *string)
查看零值指针类型，实例如下：

package main

import (
    "fmt"
)

func main() {
    var ip *int
    var sp *string

    fmt.Printf("ip : %#v\n", ip)
    fmt.Printf("sp : %#v\n", sp)
}
运行结果：

ip : (*int)(nil)
sp : (*string)(nil)
指针类型转换

Go语言是不允许两个指针类型进行转换的。

我们一般使用T作为一个指针类型，表示一个指向类型T变量的指针。为了安全的考虑，两个不同的指针类型不能相互转换，比如 *uint 不能转为 *int 。实例如下：

package main

func main() {
    var i uint = 10
    var p2 *int

    p1 := &i
    p2 = (*int)(p1)
}
编译错误：

./main.go:8:13: cannot convert p1 (type *uint) to type *int
unsafe.Pointer类型用于表示任意类型的指针。有4个特殊的只能用于Pointer类型的操作：

1、 任意类型的指针可以转换为一个Pointer类型值
2、 一个Pointer类型值可以转换为任意类型的指针
3、 一个uintptr类型值可以转换为一个Pointer类型值
4、 一个Pointer类型值可以转换为一个uintptr类型值
因此，Pointer类型允许程序绕过类型系统读写任意内存。使用它时必须谨慎。实例如下：

package main

import (
    "fmt"
    "unsafe"
)

func main() {
    var i uint = 10
    var p2 *int

    p1 := &i
    p2 = (*int)(unsafe.Pointer(p1))
    fmt.Println(*p2)
}


Go语言结构体
Go 语言中数组可以存储同一类型的数据，但在结构体中我们可以为不同项定义不同的数据类型。

结构体是由一系列具有相同类型或不同类型的数据构成的数据集合。

struct 特点
1、用来自定义复杂数据结构
2、struct里面可以包含一个或多个字段（属性）
3、struct类型可以定义方法，注意和函数的区分
4、struct类型是值类型
5、struct类型可以嵌套
6、结构体是用户单独定义的类型，不能和其他类型进行强制转换
7、Go中的struct没有构造函数，一般可以使用工厂模式来解决这个问题
8、我们可以为struct中的每个字段，写上一个tag。这个tag可以通过反射的机制获取到，最常用的场景就是json序列化和反序列化
9、访问结构体成员, 用 "." 来连接，格式为："结构体.成员名"

struct 定义

可用 type 在全局或函数内定义新类型。
第一种，定义一个新的数据类型，结构体中只有一个成员。

type bigint int64
type smallint int8
新类型不是原类型的别名，除拥有相同数据存储结构外，它们之间没有任何关系，不会持有原类型任何信息。除非目标类型是未命名类型，否则必须显式转换。

第二种，定义一个新的数据类型，结构体中有多个成员。

type oldboy struct {
    Linux  string
    Python string
    Golang string
}
第三种，定义一个新的数据类型，指向结构体的指针。

type Linux string

type oldboy struct {
    *Linux
}
不能同时嵌入某一类型和其指针类型，因为它们名字相同。实例如下：

package main

type Linux string

type oldboy struct {
    *Linux
    Linux
}

func main() {

}
编译错误：

./main.go:7:2: duplicate field Linux
struct 初始化

有序初始化: 结构体中的多个成员的值，必须一一对应。
无序初始化: 结构体中的多个成员的值，无须一一对应，可初始化部分值。

package main

type oldboy struct {
    Linux  string
    Python string
    Golang string
}

// 有序初始化
var ordered = oldboy{"linux", "python", "golang"}

// 无序初始化
var disordered = oldboy{Golang: "golang"}

func main() {
}
结构体初始化方法有如下几种：

package main

import (
    "fmt"
)

type oldboy struct {
    int
    string
}

var one oldboy

func main() {
    two := new(oldboy) //同 var two *oldboy = new(oldboy)
    three := oldboy{1, "three"}
    four := oldboy{}
    five := &oldboy{}
    six := &oldboy{2, "six"} //同 var six *oldboy = &oldboy{2, "six"}

    fmt.Println(one, two, three, four, five, six)
}
one three four 返回 oldboy 类型变量；two five six 返回 *oldboy 类型变量；若无初始化值，则默认为零值。

匿名字段

定义一个struct，定义的时候是字段名与其类型一一对应，实际上Go语言支持只提供类型，而不写字段名的方式，也就是匿名字段，或称为嵌入字段。

当匿名字段是一个struct的时候，那么这个struct所拥有的全部字段都被隐式地引入了当前定义的这个struct。

package main

import (
    "fmt"
)

type Person struct {
    name string
    age  int
    addr string
}

type Employee struct {
    Person //匿名字段
    salary int
    int           //用内置类型作为匿名字段
    addr   string //类似于重载
}

func main() {
    em1 := Employee{
        Person{"oldboy", 18, "北京"},
        10,
        100,
        "首都",
    }
    fmt.Println(em1)
    var em2 Person = em1.Person 
    fmt.Println(em2)
}
struct与tag应用

声明struct结构的时候，在属性的右侧用小米点括起来的内容叫标签（Tag），在转换成其它数据格式的时候，会使用其中特定的字段作为键值。例如转成json格式，实例如下：

package main

import (
    "encoding/json"
    "fmt"
)

type User struct {
    UserId   int
    UserName string
}
type UserTag struct {
    UserId   int    `json:"user_id" bson:"user_id"`
    UserName string `json:"user_name" bson:"user_name"`
}

func main() {
    user := &User{UserId: 1, UserName: "oldboy"}
    json_user, _ := json.Marshal(user)
    fmt.Printf("struct User echo : %v\n", string(json_user))

    user_tag := &UserTag{UserId: 1, UserName: "oldboy"}
    json_user_tag, _ := json.Marshal(user_tag)
    fmt.Printf("struct UserTag echo : %v\n", string(json_user_tag))
}
运行结果：

struct User echo : {"UserId":1,"UserName":"oldboy"}
struct UserTag echo : {"user_id":1,"user_name":"oldboy"}
标签是struct类型的组成部分：

package main

var user1 struct {
    UserId int `json:"user_id"`
}
var user2 struct {
    UserId int `bson:"user_id"`
}

func main() {
    user1 = user2
}
编译错误：

./main.go:11:8: cannot use user2 (type struct { UserId int "bson:\"user_id\"" }) as type struct { UserId int "json:\"user_id\"" } in assignment


Go语言常见语法错误
1、开大括号不能放在单独的一行

错误代码：

package main

import "fmt"

func main() 
{ 
    fmt.Println("hello world!")
}
编译错误：

./main.go:5:6: missing function body for "main"
./main.go:6:1: syntax error: unexpected semicolon or newline before {
正确代码：

package main

import "fmt"

func main() {
    fmt.Println("hello world!")
}
2、未使用的变量

如果你有未使用的局部变量，代码将编译失败。
如果你给未使用的变量分配了一个新的值，代码还是会编译失败。你需要在某个地方使用这个变量，才能让编译器愉快的编译。

错误代码：

package main

var gvar int

func main() {
    var one int
    two := 2
    var three int
    three = 3
}
编译错误：

./main.go:6:6: one declared and not used
./main.go:7:9: two declared and not used
./main.go:8:6: three declared and not used
正确代码：

package main

import "fmt"

func main() {
    var one int
    _ = one
    two := 2
    fmt.Println(two)
    var three int
    three = 3
    one = three
    var four int
    four = four
}

// 另外可以选择是注释掉或者移除未使用的变量
3、未使用的Imports

如果你引入一个包，而没有使用其中的任何函数、接口、结构体或者变量的话，代码将会编译失败。
如果你真的需要引入的包，你可以添加一个"_"下划线标记符，来作为这个包的名字，从而避免编译失败。下滑线标记符用于引入，但不使用。

错误代码：

package main

import (
    "fmt"
    "log"
    "time"
)

func main() {
}
编译错误：

./main.go:4:2: imported and not used: "fmt"
./main.go:5:2: imported and not used: "log"
./main.go:6:2: imported and not used: "time"
正确代码：

package main

import (
    _ "fmt"
    "log"
    "time"
)

var _ = log.Println

func main() {
    _ = time.Now
}

// 另外可以选择是移除或者注释掉未使用的imports
4、":="简式的变量声明仅可以在函数内部使用

错误代码：

package main

myvar := 1 

func main() {  
}
编译错误：

./main.go:3:1: syntax error: non-declaration statement outside function body
正确代码：

package main

var myvar = 1

func main() {
}
5、使用简式声明重复声明变量

你不能在一个单独的声明中重复声明一个变量，但在多变量声明中这是允许的，其中至少要有一个新的声明变量。
重复变量需要在相同的代码块内，否则你将得到一个隐藏变量。

错误代码：

package main

func main() {
    one := 0
    one := 1
}
编译错误：

./main.go:5:6: no new variables on left side of :=
正确代码：

package main

func main() {
    one := 0
    one, two := 1, 2
    one, two = two, one
}
6、Go语言命名区分大小写

错误代码：

package main

import "fmt"

func main() {
    fmt.println("Hello world")
}

// 以下代码都是不正确的:
// Package main
// iMport "fmt"
// import "Fmt"
// Func main() {}
// Fmt.Println
// fmt.println
编译错误：

./main.go:6:2: cannot refer to unexported name fmt.println
./main.go:6:2: undefined: fmt.println
正确代码：

package main

import "fmt"

func main() {
    fmt.Println("Hello world")
}
7、Go语言中分号分行

错误代码：

package main

import "fmt"

func main() {
    fmt.Println("Hello world") fmt.Println("Hi again")
}
编译错误：

./main.go:6:29: syntax error: unexpected fmt at end of statement
正确代码：

package main

import "fmt"

func main() {
    fmt.Println("Hello world")

    //解决以上问题，可以将上述的两条语句放在两行
    fmt.Println("Hi again") 

    //可以将两条语句用分号结束
    fmt.Println("Hello world");fmt.Println("Hi again") 
    test()
}

func test() { 
    //因此在Go语言中，分号能省则省，如果必须使用时，添加上也不会出错。
    fmt.Println("Hello world");fmt.Println("Hi again");
};
8、Go语言中无效的分号

错误代码：

package main

import "fmt";;

func main() {
    fmt.Println("Hello world")
}
编译错误：

./main.go:3:14: syntax error: non-declaration statement outside function body
正确代码：

package main

import "fmt";

func main() {
    fmt.Println("Hello world")
}
9、Go语言中注意变量作用域

错误代码：

package main

var num int

func main() {
    str := "hello world"
    if true {
        var b bool
    }
    println(num)
    println(str)
    println(b)
}
编译错误：

./main.go:12:10: undefined: b
正确代码：

package main

var num int

func main() {
    str := "hello world"
    if true {
        var b bool
        println(b)
    }
    println(num)
    println(str)
}
10、偶然的变量隐藏

短式变量声明的语法如此的方便（尤其对于那些使用过动态语言的开发者而言），很容易让人把它当成一个正常的分配操作。如果你在一个新的代码块中犯了这个错误，将不会出现编译错误，但你的应用将不会做你所期望的事情。

package main

import "fmt"

func main() {
    x := 1
    fmt.Println(x) // 1
    {
        fmt.Println(x) // 1
        x := 2
        fmt.Println(x) // 2
    }
    fmt.Println(x) // 1 
}
运行结果：

1
1
2
1
即使对于经验丰富的Go开发者而言，这也是一个非常常见的陷阱，但又很难发现。

你可以使用 vet命令来发现一些这样的问题。 默认情况下， vet不会执行这样的检查，你需要设置-shadow参数： 
命令：go tool vet -shadow your_file.go

go tool vet -shadow main.go
main.go:10: declaration of "x" shadows declaration at main.go:6
11、不使用显式类型，无法使用“nil”来初始化变量

nil标志符用于表示interface、函数、maps、slices和channels的“零值”。如果你不指定变量的类型，编译器将无法编译你的代码，因为它猜不出具体的类型。

错误代码：

package main

func main() {
    var x = nil
    _ = x
}
编译错误：

./main.go:4:6: use of untyped nil
正确代码：

package main

func main() {
    var x interface{} = nil
    _ = x
}
12、使用“nil” Slices and Maps

在一个nil的slice中添加元素是没问题的，但对一个map做同样的事将会生成一个运行时的panic。

正确代码：

package main

func main() {
    var s []int
    s = append(s, 1)
}
错误代码：

package main

import (
    "fmt"
)

func main() {
    var m map[int]int
    m[1] = 1
    fmt.Println(m)
}
运行错误：

panic: assignment to entry in nil map
正确代码：

package main

import (
    "fmt"
)

func main() {
    var m map[int]int
    m = make(map[int]int)
    m[1] = 1
    fmt.Println(m)
}
13、Map的容量

map 只有 len操作， 没有 cap 操作

错误代码：

package main

import (
    "fmt"
)

func main() {
    m := map[int]string{1: "a", 2: "b", 3: "c"}
    cap := cap(m)
    fmt.Println(cap)
}
编译错误：

./main.go:9:12: invalid argument m (type map[int]string) for cap
正确代码：

package main

import (
    "fmt"
)

func main() {
    m := map[int]string{1: "a", 2: "b", 3: "c"}
    len := len(m)
    fmt.Println(len)
}
14、字符串不会为nil

这对于经常使用nil分配字符串变量的开发者而言是个需要注意的地方。

package main

func main() {
    var x string = nil
    if x == nil {
        x = "default"
    }
}
编译错误：

./main.go:4:6: cannot use nil as type string in assignment
./main.go:5:7: invalid operation: x == nil (mismatched types string and nil)
正确代码：

package main

func main() {
    var x string
    if x == "" {
        x = "default"
    }
}


Go 语言 if 条件语句
条件语句需要开发者通过指定一个或多个条件，并通过测试条件是否为 true 来决定是否执行指定语句，并在条件为 false 的情况在执行另外的语句。

if 语句 由一个布尔表达式后紧跟一个或多个语句组成。

if 在布尔表达式为 true 时，其后紧跟的语句块执行，如果为 false 则不执行。

第一种，直接判断bool类型

package main

import "fmt"

func main() {
    if true {
        fmt.Println("true")
    }
}
package main

import "fmt"

func main() {
    b := true
    if b {
        fmt.Println("b := true")
    }
}
第二种，表达式中判断bool类型

package main

import "fmt"

func main() {
    var i int
    if i == 0 {
        fmt.Println("i == 0")
    }
}
package main

import "fmt"

func main() {
    var str string
    if str == "" {
        fmt.Println(`str == ""`)
    }
}
第三种，通过 &&逻辑与 ||逻辑或 ！逻辑非，判断bool类型

package main

import "fmt"

func main() {
    a := 10
    b := 20

    if a > 0 && a < b {
        fmt.Println("a > 0 && a < b")
    }

    if a < 10 || b == 20 {
        fmt.Println("a < 10 || b == 20")
    }

    if !(a == b) {
        fmt.Println("!(a == b)")
    }
}
第四种，表达式中先变量赋值后判断bool类型

package main

import "fmt"

func main() {
    if age := 18; age == 18 {
        fmt.Println("age == 18")
    }
}
if…else 语句

if 语句 后可以使用可选的 else 语句, else 语句中的表达式在布尔表达式为 false 时执行。实例如下：

package main

import (
    "fmt"
)

func main() {
    i := 10

    if i < 10 {
        fmt.Println("i<10")
    } else if i == 10 {
        fmt.Println("i=10")
    } else {
        fmt.Println("i>10")
    }
}
if 嵌套语句

你可以在 if 或 else if 语句中嵌入一个或多个 if 或 else if 语句。实例如下：

package main

import (
    "fmt"
)

func main() {
    name := "oldboy"
    age := 18
    if name == "oldboy" {
        if age == 18 {
            fmt.Println("The old boy welcomes you.")
        }
    }
}


Go语言switch条件语句
switch 语句用于基于不同条件执行不同动作。

switch 语句用于基于不同条件执行不同动作，每一个 case 分支都是唯一的，所有 case 分支的参数必须是相同的类型，语句执行的过程从上至下，直到找到匹配项，匹配项后面也不需要再加 break 默认自动终止。

switch 语句
第一种，直接判断

package main

import "fmt"

func main() {
    var i = 0
    switch i {
    case 0:
    case 1:
        fmt.Println(1)
    case 2:
        fmt.Println(2)
    default:
        fmt.Println("default")
    }
}
第二种，带初始化语句

package main

import "fmt"

func main() {
    names := []string{"Linux", "Golang", "Java", "Python"}
    switch name := names[0]; name {
    case "Golang":
        fmt.Println("Golang")
    case "Java":
        fmt.Println("Java")
    case "Python":
        fmt.Println("Python")
    default:
        fmt.Println("oldboy")
    }
}
第三种，一个 case 多个可能符合条件的值

package main

import "fmt"

func main() {
    var i = 1
    switch i {
    case 0, 1:
        fmt.Println("0 or 1")
    case 2:
        fmt.Println("2")
    default:
        fmt.Println("default")
    }
}
第四种，省略条件表达式应用

package main

import "fmt"

func main() {
    var i = 10
    switch {
    case i >= 0 && i < 10:
        fmt.Println("i > 0 and i < 10")
    case i >= 10 && i < 20:
        fmt.Println("i > 10 and i < 20")
    default:
        fmt.Println("default")
    }
}
第五种，fallthrough应用

Go语言 switch 语句每个 case 最后默认带有break，匹配成功后不会自动向下执行其他 case，而是跳出整个switch，可以使用 fallthrough 语句强制执行后面的 case 代码。

package main

import "fmt"

func main() {
    var i = 0
    switch i {
    case 0:
        fmt.Println("fallthrough")
        fallthrough
    case 1:
        fmt.Println(1)
    case 2:
        fmt.Println(2)
    default:
        fmt.Println("default")
    }
}


Go语言 select 条件语句
select 语句是Go中的一个控制结构，类似于switch语句，用于处理异步IO操作。select会监听case语句中channel的读写操作，当case中channel读写操作为非阻塞状态（即能读写）时，将会触发相应的动作。

每个case必须是一个通信操作，要么是发送要么是接收，select中的default子句总是可运行的。

如果有多个case都可以运行，select会随机公平地选出一个执行，其他不会执行。如果没有可运行的case语句，且有default语句，那么就会执行default的动作。如果没有可运行的case语句，且没有default语句，select将阻塞，直到某个case通信可以运行。

select 应用

1、select 语句基本使用

package main

import "fmt"

func main() {
    var c1, c2, c3 chan int
    var i1, i2 int
    select {
    case i1 = <-c1:
        fmt.Printf("received ", i1, " from c1\n")
    case c2 <- i2:
        fmt.Printf("sent ", i2, " to c2\n")
    case i3, ok := (<-c3):
        if ok {
            fmt.Printf("received ", i3, " from c3\n")
        } else {
            fmt.Printf("c3 is closed\n")
        }
    default:
        fmt.Printf("no communication\n")
    }
}
2、超时判断

package main

import (
    "fmt"
    "time"
)

func main() {
    ch := make(chan int)
    select {
    case i := <-ch:
        fmt.Printf("i = %d\n", i)
    case <-time.After(time.Second * 3):
        fmt.Println("time out")
    }
}
3、判断channel是否阻塞

package main

import (
    "fmt"
)

func main() {
    // 在某些情况下是存在不希望channel缓存满了的需求的，可以用如下方法判断
    ch := make(chan int, 5)
    data := 0
    select {
    case ch <- data:
        fmt.Println("ch <- data")
    default:
        fmt.Println("default")
    }
}


Go语言 for 循环语句
for循环是一个循环控制结构，可以执行指定次数的循环。

三种循环方式

第一种，常见的 for 循环，支持初始化语句

for init; condition; post { 
}
init： 一般为赋值表达式，给控制变量赋初值；
condition： 关系表达式或逻辑表达式，循环控制条件；
post： 一般为赋值表达式，给控制变量增量或减量。
for语句执行过程如下：
① 先对表达式 init 赋初值；
②判别赋值表达式 init 是否满足给定 condition 条件，若其值为真，满足循环条件，则执行循环体内语句，然后执行 post，进入第二次循环，再判别 condition；否则判断 condition 的值为假，不满足条件，就终止for循环，执行循环体外语句。

package main

import (
    "fmt"
)

func main() {
    for i := 1; i < 10; i++ {
        fmt.Println(i)
    }
}
第二种，关系表达式或逻辑表达式控制循环

for condition { }
实例如下：

package main

import (
    "fmt"
)

func main() {
    i := 0
    for i < 5 {
        i++
    }
    for i == 5 {
        fmt.Println(i)
        break
    }
}
第三种，无限循环

for {
}

for true {
}
实例如下：

package main

import (
    "fmt"
    "time"
)

func main() {
    for {
        fmt.Println("无限循环 for {}")
        time.Sleep(time.Second)
    }
}
循环嵌套

在 for 循环中可以嵌套一个或多个 for 循环，实例如下：

1、使用循环嵌套来输出九九乘法表：

package main

import "fmt"

func main() {

    for i := 1; i < 10; i++ {
        for j := 1; j <= i; j++ {
            fmt.Printf("%d * %d = %2d\t", i, j, i*j)
        }
        fmt.Println()
    }
}
2、使用循环嵌套来输出 2 到 100 间的素数：

package main

import "fmt"

func main() {
    var i, j int

    for i = 2; i < 100; i++ {
        for j = 2; j <= (i / j); j++ {
            if i%j == 0 {
                break
            }
        }
        if j > (i / j) {
            fmt.Printf("%2d  是素数\n", i)
        }
    }
}


Go语言 range 循环语句
Go 语言中 range 关键字用于 for 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素。在数组和切片中它返回元素的索引和索引对应的值，在集合中返回 key-value 对的 key 值。

字符串遍历

1、for range 英文字符串，key 值按照+1顺序递增

package main

import (
    "fmt"
)

func main() {
    var str string = "oldboy"
    for k, v := range str {
        fmt.Println(k, string(v))
    }
}
2、for range 包含中文的字符串，英文字符 key 值按照+1顺序递增，中文字符 key 值按照+3顺序递增

package main

import (
    "fmt"
)

func main() {
    var str string = "老男孩IT教育，只培养技术精英。"
    for k, v := range str {
        fmt.Println(k, string(v))
    }
}
数组遍历

1、for range 数组程序会复制对象，key、value 都是从复制品中取出

package main

import (
    "fmt"
)

func main() {

    arr := [5]int{1, 2, 3, 4, 5}
    for k, v := range arr {
        if k == 0 {
            arr[0], arr[1] = 1000, 1000
            fmt.Println("修改原数组：", arr)
        }

        // 使用复制品中取出的 value 修改原数组
        arr[k] = v + 100
    }
    fmt.Println(arr)
}
2、多维数组遍历

package main

import (
    "fmt"
)

func main() {

    var arr [2][3]int = [2][3]int{{1, 2, 3}, {2, 4, 6}}

    for k1, v1 := range arr {
        for k2, v2 := range v1 {
            fmt.Printf("%d*%d=%d ", k1+1, k2+1, v2)
        }
        fmt.Printf("\n")
    }
}
3、数组遍历值拷贝行为会造成性能问题，建议数组遍历使用引用类型slice，或数组指针。

package main

import "fmt"

func main() {
    arr := [5]int{1, 2, 3, 4, 5}
    arrP := &arr
    for k, _ := range arrP {
        if k == 0 {
            arrP[0], arrP[1] = 1000, 1000
            fmt.Println("修改原数组：", arr)
        }

        arrP[k] += 100
    }
    fmt.Println(arr)
}
slice 遍历

将所需数据 copy 到较小的 slice，以便释放底层数组内存

package main

import (
    "fmt"
)

func main() {

    arr := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
    slice := arr[:]
    for key, value := range slice {
        fmt.Printf("key: %v , value : %v\n", key, value)
    }
}
map 遍历

map 遍历不能保证迭代返回次序，通常是随机结果，具体和版本实现有关。

package main

import (
    "fmt"
)

func main() {
    m := map[int]string{
        1: "oldboy",
        2: "Linux",
        3: "Golang",
        4: "Python",
        5: "Java",
        6: "DBA",
    }
    for k, v := range m {
        fmt.Printf("%d => %s \n", k, v)
    }
}
channel 遍历

package main

import "fmt"

func main() {
    var ch chan int
    ch = make(chan int, 10)

    for i := 0; i < 10; i++ {
        ch <- i
    }

    close(ch)
    for v := range ch {
        fmt.Println(v)
    }
}
注意：如果没有 close() 因为存入管道10个数字，然后无限取数据，在取出来第10个数据，在次range管道，会dead lock。


Go语言循环控制语句
循环控制语句可以控制循环体内语句的执行过程。

GO 语言支持 goto、break、continue 三种循环控制语句，三个语句都可以配合标签（ label ）使用，标签名区分大小写，定义后不使用会造成编译错误。

goto 语句

Go语言支持在函数内 goto 跳转。goto 语句可以无条件地转移到过程中指定的行，通常与条件语句配合使用。可用来实现条件转移、构成循环、跳出循环体等功能。实例如下：

1、先定义标签后定义goto语句

package main

import "fmt"

func main() {
    var i int = 10

GO:
    for i < 20 {
        if i == 15 { //跳过迭代
            i = i + 1
            goto GO
        }
        fmt.Printf("i的值为 : %d\n", i)
        i++
    }
}
2、先定义goto语句后定义标签

package main

import "fmt"

func main() {
    var i int
    for {
        fmt.Println(i)
        i++
        if i > 2 {
            goto oldboy
        }
    }
oldboy:
    fmt.Println("golang")
}
注意：goto语句与标签之间不能有变量声明，否则编译错误。

package main

import "fmt"

func main() {
    fmt.Println("start")
    goto Loop
    var say = "hello oldboy"
    fmt.Println(say)
Loop:
    fmt.Println("end")
}
编译错误：

./main.go:7:7: goto Loop jumps over declaration of say at ./main.go:8:6
break 语句

1、break 语句中断当前 for 循环，并开始执行循环之后的语句

package main

import "fmt"

func main() {
    var i int = 10

    for i < 20 {
        fmt.Printf("i 的值为 : %d\n", i)
        i++
        if i > 15 {
            // break 语句跳出循环
            break
        }
    }
}
2、break 语句中断当前 for range 循环，并开始执行循环之后的语句

package main

import (
    "fmt"
)

func main() {
    m := map[int]string{
        1: "oldboy",
        2: "Linux",
        3: "Python",
        4: "Java",
        5: "Golang",
    }

    for k, v := range m {
        fmt.Printf("%d => %s \n", k, v)
        if v == "Golang" {
            // break 语句跳出循环
            break
        }
    }
}
3、break 语句在执行一条 case 后跳出 switch 循环

package main

import (
    "fmt"
)

func main() {

    name := "Golang"
    switch name {
    case "oldboy":
        fmt.Println(name)
        break
    case "Linux":
        fmt.Println(name)
        break
    case "Golang":
        fmt.Println(name)
        break
    case "Python":
        fmt.Println(name)
        break
    case "Java":
        fmt.Println(name)
        break
    case "DBA":
        fmt.Println(name)
        break
    }
}
4、break 语句在执行一条 case 后跳出 select 循环

package main

import "fmt"

func main() {
    var ch chan int
    ch = make(chan int, 1)
    // ch <- 1
    select {
    case i := <-ch:
        fmt.Printf("received %d %s", i, " from ch\n")
        break
    default:
        fmt.Println("break")
        break
    }
}
5、Break label 语句 跳出多层嵌套循环

package main

import (
    "fmt"
)

func main() {
    fmt.Println("start")

Exit:
    for i := 0; i < 9; i++ {
        for j := 0; j < 9; j++ {
            if i+j > 15 {
                fmt.Println("exit")
                break Exit
            }
        }
    }

    fmt.Println("end")
}
break 标签除了可以跳出 for 循环，还可以跳出 select、switch 循环。

注意：label要写在循环的开始而不是结束的地方，和goto语句不一样。

package main

import (
    "fmt"
)

func main() {
    fmt.Println("start")

    for i := 0; i < 9; i++ {
        for j := 0; j < 9; j++ {
            if i+j > 15 {
                fmt.Println("exit")
                break Exit
            }
        }
    }
Exit:
    fmt.Println("end")
}
编译错误：

./main.go:14:11: break label not defined: Exit
./main.go:18:1: label Exit defined and not used
continue 语句

1、continue 语句在 for 循环和for range 循环中用于跳过当前循环的剩余语句，然后继续进行下一轮循环。

package main

import "fmt"

func main() {
    // for 循环
    for i := 0; i < 5; i++ {
        if i == 2 {
            continue
        }
        fmt.Printf("i 的值为 : %d\n", i)
    }
    // for range 循环
    sli := []string{"Linux", "Python", "Golang", "Java"}
    for _, v := range sli {
        fmt.Println(v)
        if v != "Golang" {
            continue
        }
        fmt.Println("The old boy welcomes you.")
    }
}
2、continue label 语句可在多级嵌套循环中跳出

package main

import "fmt"

func main() {

BreakLabel:
    for i := 0; i < 3; i++ {
    ContinueLabel:
        for j := 0; j < 5; j++ {
            if j > 2 {
                continue ContinueLabel
            }
            if i > 1 {
                break BreakLabel
            }

            fmt.Print(i, ":", j, " ")
        }
        fmt.Println()
    }
}


Go语言函数定义
函数是基本的代码块，用于执行一个任务。

Go语言函数特点：

1、关键字func用来声明一个函数funcName；
2、函数可以有一个或者多个参数，每个参数后面带有类型，通过逗号（,）分隔；
3、函数可以返回多个值；
4、返回值可以使用声明变量，如果不想声明也可以直接使用返回值的类型；
5、如果只有一个返回值且不声明返回值变量，那么你可以省略 包括返回值 的括号；
6、如果没有返回值，可以直接省略最后的返回信息；
7、如果有返回值， 必须在函数的外层添加return语句，否则会引发编译错误；
8、函数也是一种类型，一个函数可以赋值给变量，可作为参数传递；
9、函数不支持嵌套，一个包不能有两个名字一样的函数。不支持重载，不支持 默认参数

函数定义

第一种，定义一个无参数，无返回值的函数

func funcName() {

}
第二种，定义一个参数，无返回值的函数

func Print(str string) {
    println(str)
}
第三种，定义多个参数的函数，一个返回值的函数

func sum(x, y int) int {
    return x + y
}
第四种，定义一个多返回值的函数

func oldboy(str string) (ret string, err error) {
    if str == "Go" {
        return "老男孩IT教育，只培养技术精英。", nil
    }
    return "", errors.New("error")
}
第五种，返回值只有类型，无变量声明函数

func oldboy(str string) (string, error) {
    if str == "Go" {
        return "老男孩IT教育，只培养技术精英。", nil
    }
    return "", errors.New("error")
}
函数类型

第一种，定义一个无参数，无返回值的函数类型

type funcType func()
第二种，定义一个参数，无返回值的函数类型

type funcType func(string)
第三种，定义多个参数的函数，一个返回值的函数类型

type funcType func(x, y int) int
第四种，定义一个多返回值的函数类型

type funcType func(string) (string, error)


Go语言函数参数
函数参数

实际参数简称“实参”。在调用有参函数时，函数名后面括号中的参数称为“实际参数”，实参可以是常量、变量或表达式。

自定义函数中的“形参”全称为"形式参数" 由于它不是实际存在变量，所以又称虚拟变量。实参和形参可以重名。形参的作用域是整个函数体就像定义在函数体内的局部变量。

参数传递

第一种，值传递：指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。

package main

import (
    "fmt"
)

func main() {
    var x int = 1
    var y int = 2
    // 值传递
    z := sum(x, y)
    fmt.Println(z)
}

func sum(x, y int) int {
    return x + y
}
第二种，引用传递：是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。

package main
import (
    "fmt"
)

func swap(x, y *string) {
    var temp string

    temp = *x
    *x = *y
    *y = temp

}

func main() {
    var course1, course2 string = "Python", "Golang"

    swap(&course1, &course2)

    fmt.Println(course1, course2)
}
第三种，固定类型可变参数：就是函数的参数不是固定的，后面的类型是固定的。

package main

import (
    "fmt"
)

func variable(name string, course ...string) {
    fmt.Println("可变参数的长度:", len(course))
    for _, val := range course {
        fmt.Println(name, val)
    }
}

func main() {
    variable("oldboy", "linux", "golang", "python", "java")
}
第四种，任意类型的不定参数：就是函数的参数和每个参数的类型都不是固定的。形参用interface{}传递任意类型数据。

package main

import (
    "fmt"
)

type Person struct {
    name string
}

func variable(values ...interface{}) {
    for _, val := range values {
        switch v := val.(type) {
        case int:
            fmt.Println("val type is int ", v)
        case float64:
            fmt.Println("val type is float ", v)
        case string:
            fmt.Println("val type is string ", v)
        case bool:
            fmt.Println("val type is bool ", v)
        case Person:
            fmt.Println("val type is Person ", v.name)
        case *Person:
            fmt.Println("val type is *Person ", v.name)
        default:
            fmt.Println("val type is unknow ", v)
        }
    }
}

func main() {
    temp_int := 1
    temp_float := 5.6
    temp_string := "hello"
    temp_bool := true
    temp_person1 := &Person{name: "jack"}
    temp_person2 := Person{name: "rose"}
    var temp_float32 float32 = 6.6

    variable(temp_int, temp_float, temp_string, temp_bool, temp_person1, temp_person2, temp_float32)
}
第五种，函数类型参数：就是函数类型赋值给变量，作为参数传递应用。

package main

import "fmt"

// 定义函数类型
type myfunc func(string, string)

func addperfix(perfix, name string) {
    fmt.Println(perfix, name)
}

// 第二个参数用匿名函数当参数
func sayhello(name string, f myfunc) {
    f("hello", name)
}

func main() {
    sayhello("oldboy", addperfix)
}
注意：

1、Go语言函数中的参数不支持默认值。

2、无论是值传递，还是引用传递，传递给函数的都是变量的副本，不过，值传递是值的拷贝。引用传递是地址的拷贝，一般来说，地址拷贝更为高效。而值拷贝取决于拷贝的对象大小，对象越大，则性能越低。

3、map、slice、chan、指针、interface默认以引用的方式传递。

4、函数的可变参数只能有一个，且必须是最后一个。

5、在参数赋值时可以不用用一个一个的赋值，可以直接传递一个数组或者切片，特别注意的是在参数后加上“…”即可。实例如下：

package main

import (
    "fmt"
)

func oldboy(name string, c ...string) string {
    var course string
    for _, val := range c {
        course += val
    }

    return fmt.Sprintf(name, course)
}

func main() {
    course := []string{"linux ", "golang ", "python ", "java"}
    res := oldboy("oldboy: %s", course...) // ... 展开slice
    fmt.Println(res)
}


Go语言函数返回值
返回值定义

返回值通过使用返回语句返回。可以返回任意类型。返回语句会立即中止函数的运行，并且将控制权交回调用该函数的代码行。

Go语言函数可以有零个或多个返回值，可以返回多个不同类型的结果。当函数有返回值 return 语句必须要写，否则编译器会报错。

Go语言在定义函数时返回值可以被命名，命名返回值的作用域是整个函数体就像定义在函数体内的局部变量。在 return 语句中，无需显示的返回这些值，Go 会自动将其返回。

返回值应用

1、零返回值

package main

import (
    "fmt"
)

func oldboy() {
    fmt.Println("老男孩IT教育，只培养技术精英。")
}

func main() {
    oldboy()
}
2、多返回值

package main

import (
    "fmt"
)

func course(name string) (string, string, string, string, string) {
    return "Linux", "Python", "Golang", "Java", "DBA"
}

func main() {
    fmt.Println(course("oldboy"))
}
3、显式返回值，return 语句后必须带返回的结果。

package main

import (
    "fmt"
)

func sum(x, y int) int {
    return x + y
}

func main() {
    fmt.Println(sum(1, 2))
}
4、隐式返回值，只有 return 语句自动返回命名返回值。

package main

import (
    "fmt"
)

func sum(x, y int) (z int) {
    z = x + y
    return
}

func main() {
    fmt.Println(sum(1, 2))
}
巧用return

第一种，无返回值函数，在内部任何程序执行片段使用return ，直接会跳出该函数，return下面的程序片段都不会再执行。

package main

import (
    "fmt"
)

func test() {
    for i := 10; i < 100; i++ {
        fmt.Printf("%v\n", i)
        if i == 11 {
            return
        }
    }
}

func main() {
    test()
}
第二种，有返回值函数，在内部任何程序执行片段使用return，它下面的程序片段都不会再执行，但是程序结尾必须以return结束，否则程序报错。

package main

import (
    "fmt"
)

func test() int {
    i := 0
    for i = 10; i < 100; i++ {
        fmt.Printf("%v\n", i)
        if i == 11 {
            return i
        }
    }
    return i
}

func main() {
    _ = test()
}


Go语言闭包函数
基本概念

闭包是可以包含自由（未绑定到特定对象）变量的代码块，这些变量不在这个代码块内或者任何全局上下文中定义，而是在定义代码块的环境中定义。要执行的代码块（由于自由变量包含在代码块中，所以这些自由变量以及它们引用的对象没有被释放）为自由变量提供绑定的计算环境（作用域）。

闭包的价值

闭包的价值在于可以作为函数对象或者匿名函数，对于类型系统而言，这意味着不仅要表示数据还要表示代码。支持闭包的多数语言都将函数作为第一级对象，就是说这些函数可以存储到变量中作为参数传递给其他函数，最重要的是能够被函数动态创建和返回。

Go语言闭包

1、Go语言是支持闭包的，实例如下：

package main

import (
    "fmt"
)

func a() func() int {
    i := 0
    b := func() int {
        i++
        fmt.Println(i)
        return i
    }
    return b
}

func main() {
    c := a()
    c()
    c()
    c()

    a() 

    fmt.Println("-------")

    d := a()
    d()
    d()
    d()
}
运行结果：

1
2
3
-------
1
2
3
上述代码分析：

函数b嵌套在函数a内部，函数a返回函数b。

代码在执行完 c := a() 后，变量c实际上是指向了函数b()，再执行函数c()后就会显示 i 的值，第一次为1，第二次为2，第三次为3，以此类推。
其实，这段代码就创建了一个闭包。因为函数 a() 外的变量 c 引用了函数 a() 内的函数 b() ，就是说：

当函数 a() 的内部函数 b() 被函数 a() 外的一个变量引用的时候，就创建了一个闭包。
在上面的例子中，由于闭包的存在使得函数 a() 返回后，a 中的 i 始终存在，这样每次执行 c() ，i都是自加1后的值。
从上面可以看出闭包的作用就是在a()执行完并返回后，闭包使得Golang的垃圾回收机制GC不会收回 a() 所占用的资源，因为 a() 的内部函数 b() 的执行需要依赖 a() 中的变量 i 。

在给定函数被多次调用的过程中，这些私有变量能够保持其持久性。变量的作用域仅限于包含它们的函数，因此无法从其它程序代码部分进行访问。不过，变量的生存期是可以很长，在一次函数调用期间所创建所生成的值在下次函数调用时仍然存在。正因为这一特点，闭包可以用来完成信息隐藏，并进而应用于需要状态表达的某些编程范型中。

如果 a() 返回的不是函数 b() ，情况就完全不同了。因为 a() 执行完后，b() 没有被返回给 a() 的外界，只是被 a() 所引用，而此时 a() 也只会被 b() 引 用，因此函数 a() 和 b() 互相引用但又不被外界引用，函数 a 和 函数 b 就会被GC回收。所以直接调用 a() 并没有信息输出。

c() 跟 d() 引用的是不同的环境，在调用 i++ 时修改的不是同一个 i，因此两次的输出都是1。函数 a() 每进入一次，就形成了一个新的环境，对应的闭包中，函数都是同一个函数，环境却是引用不同的环境。这和 c() 和 d() 的调用顺序都是无关的。

2、Go语言闭包复制的是原对象指针，实例如下：

package main

import "fmt"

func oldboy() func() {
    str := "oldboy"
    fmt.Printf("str (%p) = %s\n", &str, str)

    return func() {
        fmt.Printf("str (%p) = %s\n", &str, str)
    }
}

func main() {
    o := oldboy()
    o()
}
运行结果：

str (0xc42000e1d0) = oldboy
str (0xc42000e1d0) = oldboy